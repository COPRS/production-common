<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>AbstractJobsGenerator.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Spring Boot Docker For Job Generator App</a> &gt; <a href="index.source.html" class="el_package">esa.s1pdgs.cpoc.jobgenerator.tasks</a> &gt; <span class="el_source">AbstractJobsGenerator.java</span></div><h1>AbstractJobsGenerator.java</h1><pre class="source lang-java linenums">package esa.s1pdgs.cpoc.jobgenerator.tasks;

import java.io.File;
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ThreadLocalRandom;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

import javax.xml.bind.JAXBException;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.util.CollectionUtils;
import org.springframework.util.StringUtils;

import esa.s1pdgs.cpoc.appcatalog.client.job.AbstractAppCatalogJobService;
import esa.s1pdgs.cpoc.appcatalog.common.rest.model.job.AppDataJobDto;
import esa.s1pdgs.cpoc.appcatalog.common.rest.model.job.AppDataJobDtoState;
import esa.s1pdgs.cpoc.appcatalog.common.rest.model.job.AppDataJobGenerationDtoState;
import esa.s1pdgs.cpoc.common.ProductFamily;
import esa.s1pdgs.cpoc.common.errors.AbstractCodedException;
import esa.s1pdgs.cpoc.common.errors.InternalErrorException;
import esa.s1pdgs.cpoc.common.errors.processing.JobGenBuildTaskTableException;
import esa.s1pdgs.cpoc.common.errors.processing.JobGenInputsMissingException;
import esa.s1pdgs.cpoc.common.errors.processing.JobGenMetadataException;
import esa.s1pdgs.cpoc.jobgenerator.config.JobGeneratorSettings;
import esa.s1pdgs.cpoc.jobgenerator.config.ProcessSettings;
import esa.s1pdgs.cpoc.jobgenerator.model.JobGeneration;
import esa.s1pdgs.cpoc.jobgenerator.model.ProductMode;
import esa.s1pdgs.cpoc.jobgenerator.model.converter.TaskTableToJobOrderConverter;
import esa.s1pdgs.cpoc.jobgenerator.model.joborder.JobOrder;
import esa.s1pdgs.cpoc.jobgenerator.model.joborder.JobOrderInput;
import esa.s1pdgs.cpoc.jobgenerator.model.joborder.JobOrderInputFile;
import esa.s1pdgs.cpoc.jobgenerator.model.joborder.JobOrderOutput;
import esa.s1pdgs.cpoc.jobgenerator.model.joborder.JobOrderSensingTime;
import esa.s1pdgs.cpoc.jobgenerator.model.joborder.JobOrderTimeInterval;
import esa.s1pdgs.cpoc.jobgenerator.model.joborder.enums.JobOrderDestination;
import esa.s1pdgs.cpoc.jobgenerator.model.joborder.enums.JobOrderFileNameType;
import esa.s1pdgs.cpoc.jobgenerator.model.metadata.SearchMetadata;
import esa.s1pdgs.cpoc.jobgenerator.model.metadata.SearchMetadataQuery;
import esa.s1pdgs.cpoc.jobgenerator.model.metadata.SearchMetadataResult;
import esa.s1pdgs.cpoc.jobgenerator.model.tasktable.TaskTable;
import esa.s1pdgs.cpoc.jobgenerator.model.tasktable.TaskTableInput;
import esa.s1pdgs.cpoc.jobgenerator.model.tasktable.TaskTableInputAlternative;
import esa.s1pdgs.cpoc.jobgenerator.model.tasktable.TaskTablePool;
import esa.s1pdgs.cpoc.jobgenerator.model.tasktable.TaskTableTask;
import esa.s1pdgs.cpoc.jobgenerator.model.tasktable.enums.TaskTableInputOrigin;
import esa.s1pdgs.cpoc.jobgenerator.model.tasktable.enums.TaskTableMandatoryEnum;
import esa.s1pdgs.cpoc.jobgenerator.service.XmlConverter;
import esa.s1pdgs.cpoc.jobgenerator.service.metadata.MetadataService;
import esa.s1pdgs.cpoc.jobgenerator.service.mqi.OutputProducerFactory;
import esa.s1pdgs.cpoc.mqi.model.queue.LevelJobDto;
import esa.s1pdgs.cpoc.mqi.model.queue.LevelJobInputDto;
import esa.s1pdgs.cpoc.mqi.model.queue.LevelJobOutputDto;
import esa.s1pdgs.cpoc.mqi.model.queue.LevelJobPoolDto;
import esa.s1pdgs.cpoc.mqi.model.queue.LevelJobTaskDto;

/**
 * Class for processing product for a given task table
 * 
 * @author Cyrielle Gailliard
 */
public abstract class AbstractJobsGenerator&lt;T&gt; implements Runnable {

    /**
     * Logger
     */
<span class="fc" id="L75">    protected static final Logger LOGGER =</span>
<span class="fc" id="L76">            LogManager.getLogger(AbstractJobsGenerator.class);</span>

    /**
     * Use to generate an incremental id for locally upload session files
     */
<span class="fc" id="L81">    private static final AtomicInteger INCREMENT_JOB = new AtomicInteger(0);</span>

    /**
     * Producer in topic
     */
    private final OutputProducerFactory outputFactory;

    /**
     * XML converter
     */
    protected final XmlConverter xmlConverter;

    /**
     * 
     */
    protected final MetadataService metadataService;

    /**
     * 
     */
    protected final ProcessSettings l0ProcessSettings;

    protected final JobGeneratorSettings jobGeneratorSettings;

    /**
     * Applicative data service
     */
    private final AbstractAppCatalogJobService&lt;T&gt; appDataService;

    /**
     * Task table
     */
    protected String taskTableXmlName;
    protected TaskTable taskTable;
    protected List&lt;List&lt;String&gt;&gt; tasks;
    protected ProductMode mode;
    protected String prefixLogMonitor;
    protected String prefixLogMonitorRemove;

    /**
     * Template of job order. Contains all information except ones specific to
     * the session:
     * &lt;ul&gt;
     * &lt;li&gt;Inputs&lt;/li&gt;
     * &lt;li&gt;Configuration &gt; Sensing time&lt;/li&gt;
     * &lt;li&gt;Partial outputs: the work directory shall be put in front of each
     * filename&lt;/li&gt;
     * &lt;/ul&gt;
     */
    protected JobOrder jobOrderTemplate;

    /**
     * List of queries for metadata
     */
    protected final Map&lt;Integer, SearchMetadataQuery&gt; metadataSearchQueries;

    /**
     * Constructor
     * 
     * @param xmlConverter
     */
    public AbstractJobsGenerator(final XmlConverter xmlConverter,
            final MetadataService metadataService,
            final ProcessSettings l0ProcessSettings,
            final JobGeneratorSettings taskTablesSettings,
            final OutputProducerFactory outputFactory,
<span class="fc" id="L147">            final AbstractAppCatalogJobService&lt;T&gt; appDataService) {</span>
<span class="fc" id="L148">        this.xmlConverter = xmlConverter;</span>
<span class="fc" id="L149">        this.metadataService = metadataService;</span>
<span class="fc" id="L150">        this.l0ProcessSettings = l0ProcessSettings;</span>
<span class="fc" id="L151">        this.jobGeneratorSettings = taskTablesSettings;</span>
<span class="fc" id="L152">        this.metadataSearchQueries = new HashMap&lt;&gt;();</span>
<span class="fc" id="L153">        this.outputFactory = outputFactory;</span>
<span class="fc" id="L154">        this.tasks = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L155">        this.mode = ProductMode.BLANK;</span>
<span class="fc" id="L156">        this.appDataService = appDataService;</span>
<span class="fc" id="L157">    }</span>

    // ----------------------------------------------------
    // INITIALIZATION
    // ----------------------------------------------------

    /**
     * @param mode
     *            the mode to set
     */
    public void setMode(ProductMode mode) {
<span class="fc" id="L168">        this.mode = mode;</span>
<span class="fc" id="L169">    }</span>

    /**
     * Initialize the processor from the tasktable XML file
     * 
     * @param xmlFile
     */
    public void initialize(File xmlFile) throws JobGenBuildTaskTableException {

        // Build task table
<span class="fc" id="L179">        this.taskTableXmlName = xmlFile.getName();</span>
<span class="fc" id="L180">        this.buildTaskTable(xmlFile);</span>
<span class="fc" id="L181">        this.prefixLogMonitor =</span>
                &quot;[MONITOR] [step 3] [taskTable &quot; + this.taskTableXmlName + &quot;]&quot;;
<span class="fc" id="L183">        this.prefixLogMonitorRemove =</span>
                &quot;[MONITOR] [step 4] [taskTable &quot; + this.taskTableXmlName + &quot;]&quot;;

        // Build jobOrder
<span class="fc" id="L187">        this.buildJobOrderTemplate();</span>

        // Build list of metadata search query and linked to task table input
        // alternative
<span class="fc" id="L191">        this.buildMetadataSearchQuery();</span>

        // Build the tasks
<span class="fc" id="L194">        this.buildTasks();</span>

        // Retrieve list of inputs
<span class="fc" id="L197">        LOGGER.info(String.format(&quot;TaskTable %s initialized&quot;,</span>
<span class="fc" id="L198">                taskTable.getProcessorName()));</span>
<span class="fc" id="L199">    }</span>

    /**
     * Build the object TaskTable from XML file
     * 
     * @param xmlFile
     * @throws BuildTaskTableException
     */
    private void buildTaskTable(File xmlFile)
            throws JobGenBuildTaskTableException {
        // Retrieve task table
        try {
<span class="fc" id="L211">            this.taskTable = (TaskTable) xmlConverter</span>
<span class="fc" id="L212">                    .convertFromXMLToObject(xmlFile.getAbsolutePath());</span>
<span class="fc" id="L213">            this.taskTable.setLevel(this.l0ProcessSettings.getLevel());</span>
<span class="fc" id="L214">        } catch (IOException | JAXBException e) {</span>
<span class="fc" id="L215">            throw new JobGenBuildTaskTableException(this.taskTableXmlName,</span>
<span class="fc" id="L216">                    e.getMessage(), e);</span>
<span class="fc" id="L217">        }</span>
<span class="fc" id="L218">    }</span>

    private void buildJobOrderTemplate() {
        // Build from task table
<span class="fc" id="L222">        TaskTableToJobOrderConverter converter =</span>
                new TaskTableToJobOrderConverter();
<span class="fc" id="L224">        this.jobOrderTemplate = converter.apply(this.taskTable);</span>

        // Update values from configuration file
<span class="fc" id="L227">        this.jobOrderTemplate.getConf().getProcParams().forEach(item -&gt; {</span>
<span class="fc" id="L228">            if (this.l0ProcessSettings.getParams()</span>
<span class="fc bfc" id="L229" title="All 2 branches covered.">                    .containsKey(item.getName())) {</span>
<span class="fc" id="L230">                item.setValue(</span>
<span class="fc" id="L231">                        this.l0ProcessSettings.getParams().get(item.getName()));</span>
            }
<span class="fc" id="L233">        });</span>
<span class="fc" id="L234">        this.jobOrderTemplate.getConf()</span>
<span class="fc" id="L235">                .setStdoutLogLevel(this.l0ProcessSettings.getLoglevelstdout());</span>
<span class="fc" id="L236">        this.jobOrderTemplate.getConf()</span>
<span class="fc" id="L237">                .setStderrLogLevel(this.l0ProcessSettings.getLoglevelstderr());</span>
<span class="fc" id="L238">        this.jobOrderTemplate.getConf().setProcessingStation(</span>
<span class="fc" id="L239">                this.l0ProcessSettings.getProcessingstation());</span>

        // Update outputs from configuration file
<span class="fc" id="L242">        this.jobOrderTemplate.getProcs().stream()</span>
<span class="pc bpc" id="L243" title="1 of 2 branches missed.">                .filter(proc -&gt; !proc.getOutputs().isEmpty())</span>
<span class="fc" id="L244">                .flatMap(proc -&gt; proc.getOutputs().stream())</span>
<span class="fc" id="L245">                .filter(output -&gt; output</span>
<span class="fc bfc" id="L246" title="All 2 branches covered.">                        .getFileNameType() == JobOrderFileNameType.REGEXP)</span>
<span class="fc" id="L247">                .forEach(output -&gt; {</span>
<span class="fc" id="L248">                    if (this.l0ProcessSettings.getOutputregexps()</span>
<span class="fc bfc" id="L249" title="All 2 branches covered.">                            .containsKey(output.getFileType())) {</span>
<span class="fc" id="L250">                        output.setFileName(this.l0ProcessSettings</span>
<span class="fc" id="L251">                                .getOutputregexps().get(output.getFileType()));</span>
                    } else {
<span class="fc" id="L253">                        output.setFileName(</span>
<span class="fc" id="L254">                                &quot;^.*&quot; + output.getFileType() + &quot;.*$&quot;);</span>
                    }
<span class="fc" id="L256">                });</span>

        // Update the output family according configuration file
<span class="fc" id="L259">        this.jobOrderTemplate.getProcs().stream()</span>
<span class="pc bpc" id="L260" title="1 of 2 branches missed.">                .filter(proc -&gt; !proc.getOutputs().isEmpty())</span>
<span class="fc" id="L261">                .flatMap(proc -&gt; proc.getOutputs().stream()).forEach(output -&gt; {</span>
<span class="fc" id="L262">                    if (this.jobGeneratorSettings.getOutputfamilies()</span>
<span class="fc bfc" id="L263" title="All 2 branches covered.">                            .containsKey(output.getFileType())) {</span>
<span class="fc" id="L264">                        output.setFamily(this.jobGeneratorSettings</span>
<span class="fc" id="L265">                                .getOutputfamilies().get(output.getFileType()));</span>
                    } else {
<span class="fc" id="L267">                        output.setFamily(ProductFamily.fromValue(</span>
<span class="fc" id="L268">                                this.jobGeneratorSettings.getDefaultfamily()));</span>
                    }
<span class="fc" id="L270">                });</span>
<span class="fc" id="L271">    }</span>

    private void buildMetadataSearchQuery() {
<span class="fc" id="L274">        LOGGER.info(&quot;TESTLOG: inpuit families {}&quot;, this.jobGeneratorSettings.getInputfamilies());</span>
<span class="fc" id="L275">        final AtomicInteger counter = new AtomicInteger(0);</span>
<span class="fc" id="L276">        this.taskTable.getPools().stream()</span>
<span class="pc bpc" id="L277" title="1 of 2 branches missed.">                .filter(pool -&gt; !CollectionUtils.isEmpty(pool.getTasks()))</span>
<span class="fc" id="L278">                .flatMap(pool -&gt; pool.getTasks().stream())</span>
<span class="pc bpc" id="L279" title="1 of 2 branches missed.">                .filter(task -&gt; !CollectionUtils.isEmpty(task.getInputs()))</span>
<span class="fc" id="L280">                .flatMap(task -&gt; task.getInputs().stream())</span>
<span class="fc" id="L281">                .filter(input -&gt; !CollectionUtils</span>
<span class="fc bfc" id="L282" title="All 2 branches covered.">                        .isEmpty(input.getAlternatives()))</span>
<span class="fc" id="L283">                .flatMap(input -&gt; input.getAlternatives().stream())</span>
<span class="fc bfc" id="L284" title="All 2 branches covered.">                .filter(alt -&gt; alt.getOrigin() == TaskTableInputOrigin.DB)</span>
<span class="fc" id="L285">                .collect(Collectors.groupingBy(</span>
                        TaskTableInputAlternative::getTaskTableInputAltKey))
<span class="fc" id="L287">                .forEach((k, v) -&gt; {</span>
<span class="fc" id="L288">                    String fileType = k.getFileType();</span>
<span class="fc" id="L289">                    if (this.jobGeneratorSettings.getMapTypeMeta()</span>
<span class="fc bfc" id="L290" title="All 2 branches covered.">                            .containsKey(k.getFileType())) {</span>
<span class="fc" id="L291">                        fileType = this.jobGeneratorSettings.getMapTypeMeta()</span>
<span class="fc" id="L292">                                .get(k.getFileType());</span>
                    }
<span class="fc" id="L294">                    ProductFamily family = ProductFamily.BLANK;</span>
<span class="fc" id="L295">                    if (this.jobGeneratorSettings.getInputfamilies()</span>
<span class="fc bfc" id="L296" title="All 2 branches covered.">                            .containsKey(fileType)) {</span>
<span class="fc" id="L297">                        family = this.jobGeneratorSettings.getInputfamilies()</span>
<span class="fc" id="L298">                                .get(fileType);</span>
                    }
<span class="fc" id="L300">                    SearchMetadataQuery query = new SearchMetadataQuery(</span>
<span class="fc" id="L301">                            counter.incrementAndGet(), k.getRetrievalMode(),</span>
<span class="fc" id="L302">                            k.getDeltaTime0(), k.getDeltaTime1(), fileType,</span>
                            family);
<span class="fc" id="L304">                    this.metadataSearchQueries.put(counter.get(), query);</span>
<span class="fc" id="L305">                    v.forEach(alt -&gt; {</span>
<span class="fc" id="L306">                        alt.setIdSearchMetadataQuery(counter.get());</span>
<span class="fc" id="L307">                    });</span>
<span class="fc" id="L308">                });</span>
<span class="fc" id="L309">    }</span>

    protected void buildTasks() {
<span class="fc" id="L312">        this.taskTable.getPools().forEach(pool -&gt; {</span>
<span class="fc" id="L313">            this.tasks.add(</span>
<span class="fc" id="L314">                    pool.getTasks().stream().map(TaskTableTask::getFileName)</span>
<span class="fc" id="L315">                            .collect(Collectors.toList()));</span>
<span class="fc" id="L316">        });</span>
<span class="fc" id="L317">    }</span>

    // ----------------------------------------------------
    // JOB GENERATION
    // ----------------------------------------------------

    @Override
    public void run() {
<span class="fc" id="L325">        JobGeneration&lt;T&gt; job = null;</span>

        // Get a job to generate
        try {
<span class="fc" id="L329">            List&lt;AppDataJobDto&lt;T&gt;&gt; jobs = appDataService</span>
<span class="nc" id="L330">                    .findNByPodAndGenerationTaskTableWithNotSentGeneration(</span>
<span class="fc" id="L331">                            l0ProcessSettings.getHostname(), taskTableXmlName);</span>
            // Determine job to process
<span class="nc bnc" id="L333" title="All 2 branches missed.">            if (CollectionUtils.isEmpty(jobs)) {</span>
<span class="nc" id="L334">                job = null;</span>
            } else {
<span class="nc bnc" id="L336" title="All 2 branches missed.">                for (AppDataJobDto&lt;T&gt; appDataJob : jobs) {</span>
                    // Check if we can do a loop
<span class="nc" id="L338">                    long currentTimestamp = System.currentTimeMillis();</span>
<span class="nc" id="L339">                    boolean todo = false;</span>
<span class="nc" id="L340">                    job = new JobGeneration&lt;&gt;(appDataJob, taskTableXmlName);</span>
<span class="nc bnc" id="L341" title="All 3 branches missed.">                    switch (job.getGeneration().getState()) {</span>
                        case INITIAL:
<span class="nc bnc" id="L343" title="All 2 branches missed.">                            if (job.getGeneration().getLastUpdateDate() == null</span>
<span class="nc" id="L344">                                    || job.getGeneration().getLastUpdateDate()</span>
<span class="nc" id="L345">                                            .getTime() &lt; currentTimestamp</span>
                                                    - jobGeneratorSettings
<span class="nc" id="L347">                                                            .getWaitprimarycheck()</span>
<span class="nc bnc" id="L348" title="All 2 branches missed.">                                                            .getTempo()) {</span>
<span class="nc" id="L349">                                todo = true;</span>
                            }
                            break;
                        case PRIMARY_CHECK:
<span class="nc" id="L353">                            if (job.getGeneration().getLastUpdateDate()</span>
<span class="nc" id="L354">                                    .getTime() &lt; currentTimestamp</span>
                                            - jobGeneratorSettings
<span class="nc" id="L356">                                                    .getWaitmetadatainput()</span>
<span class="nc bnc" id="L357" title="All 2 branches missed.">                                                    .getTempo()) {</span>
<span class="nc" id="L358">                                todo = true;</span>
                            }
                            break;
                        default:
<span class="nc" id="L362">                            todo = true;</span>
                            break;
                    }
<span class="nc bnc" id="L365" title="All 2 branches missed.">                    if (todo) {</span>
<span class="nc" id="L366">                        job.setJobOrder(new JobOrder(this.jobOrderTemplate,</span>
<span class="nc" id="L367">                                this.l0ProcessSettings.getLevel()));</span>
<span class="nc bnc" id="L368" title="All 2 branches missed.">                        for (Integer key : metadataSearchQueries.keySet()) {</span>
<span class="nc" id="L369">                            SearchMetadataQuery query =</span>
<span class="nc" id="L370">                                    metadataSearchQueries.get(key);</span>
<span class="nc" id="L371">                            job.getMetadataQueries().put(key,</span>
                                    new SearchMetadataResult(
                                            new SearchMetadataQuery(query)));
<span class="nc" id="L374">                        }</span>
<span class="nc" id="L375">                        break;</span>
                    } else {
<span class="nc" id="L377">                        job = null;</span>
                    }
<span class="nc" id="L379">                }</span>
            }
<span class="fc" id="L381">        } catch (AbstractCodedException ace) {</span>
<span class="fc" id="L382">            LOGGER.error(&quot;{} CAnnot retrieve the current jobs: {}&quot;,</span>
<span class="fc" id="L383">                    this.prefixLogMonitor, ace.getLogMessage());</span>
<span class="nc" id="L384">        }</span>

<span class="pc bpc" id="L386" title="1 of 2 branches missed.">        if (job != null) {</span>
<span class="nc" id="L387">            String productName =</span>
<span class="nc" id="L388">                    job.getAppDataJob().getProduct().getProductName();</span>

            try {
<span class="nc" id="L391">                LOGGER.debug(</span>
                        &quot;{} [productName {}] [status {}] Trying job generation&quot;,
                        this.prefixLogMonitor, productName,
<span class="nc" id="L394">                        job.getGeneration().getState());</span>

                // Check primary input
<span class="nc" id="L397">                if (job.getGeneration()</span>
<span class="nc bnc" id="L398" title="All 2 branches missed.">                        .getState() == AppDataJobGenerationDtoState.INITIAL) {</span>
                    try {
<span class="nc bnc" id="L400" title="All 2 branches missed.">                        if (job.getGeneration().getNbErrors() == 0) {</span>
<span class="nc" id="L401">                            LOGGER.info(</span>
                                    &quot;{} [REPORT] [s1pdgsTask {}JobGeneration] [subTask Generation] [START] [productName {}] [inputs {}] Trying job generation&quot;,
                                    this.prefixLogMonitor,
<span class="nc" id="L404">                                    this.taskTable.getLevel(), productName,</span>
<span class="nc" id="L405">                                    job.getGeneration().getTaskTable());</span>
                        }
<span class="nc" id="L407">                        LOGGER.info(</span>
                                &quot;{} [productName {}] 1 - Checking the pre-requirements&quot;,
                                this.prefixLogMonitor, productName);
<span class="nc" id="L410">                        this.preSearch(job);</span>
<span class="nc" id="L411">                        AppDataJobDto&lt;T&gt; modifiedJob = appDataService.patchJob(</span>
<span class="nc" id="L412">                                job.getAppDataJob().getIdentifier(),</span>
<span class="nc" id="L413">                                job.getAppDataJob(), false, true, false);</span>
<span class="nc" id="L414">                        job.setAppDataJob(modifiedJob);</span>
<span class="nc" id="L415">                        updateState(job,</span>
                                AppDataJobGenerationDtoState.PRIMARY_CHECK);
<span class="nc" id="L417">                    } catch (AbstractCodedException e) {</span>
<span class="nc" id="L418">                        updateState(job, AppDataJobGenerationDtoState.INITIAL);</span>
<span class="nc" id="L419">                        LOGGER.error(</span>
                                &quot;{} [productName {}] 1 - Pre-requirements not checked: {}&quot;,
                                this.prefixLogMonitor, productName,
<span class="nc" id="L422">                                e.getLogMessage());</span>
<span class="nc" id="L423">                    }</span>
                }

                // Search input
<span class="nc" id="L427">                if (job.getGeneration()</span>
<span class="nc bnc" id="L428" title="All 2 branches missed.">                        .getState() == AppDataJobGenerationDtoState.PRIMARY_CHECK) {</span>
                    try {
<span class="nc" id="L430">                        LOGGER.info(&quot;{} [productName {}] 2 - Searching inputs&quot;,</span>
<span class="nc" id="L431">                                this.prefixLogMonitor, job.getAppDataJob()</span>
<span class="nc" id="L432">                                        .getProduct().getProductName());</span>
<span class="nc" id="L433">                        this.inputsSearch(job);</span>
<span class="nc" id="L434">                        updateState(job, AppDataJobGenerationDtoState.READY);</span>
<span class="nc" id="L435">                    } catch (AbstractCodedException e) {</span>
<span class="nc" id="L436">                        updateState(job,</span>
                                AppDataJobGenerationDtoState.PRIMARY_CHECK);
<span class="nc" id="L438">                        LOGGER.error(</span>
                                &quot;{} [productName {}] 2 - Inputs not found: {}&quot;,
                                this.prefixLogMonitor, productName,
<span class="nc" id="L441">                                e.getLogMessage());</span>
<span class="nc" id="L442">                    }</span>
                }

                // Prepare and send job if ready
<span class="nc" id="L446">                if (job.getGeneration()</span>
<span class="nc bnc" id="L447" title="All 2 branches missed.">                        .getState() == AppDataJobGenerationDtoState.READY) {</span>
                    try {
<span class="nc" id="L449">                        LOGGER.info(&quot;{} [productName {}] 2 - Searching inputs&quot;,</span>
<span class="nc" id="L450">                                this.prefixLogMonitor, job.getAppDataJob()</span>
<span class="nc" id="L451">                                        .getProduct().getProductName());</span>
<span class="nc" id="L452">                        this.inputsSearch(job);</span>
<span class="nc" id="L453">                        LOGGER.info(&quot;{} [productName {}] 3 - Sending job&quot;,</span>
<span class="nc" id="L454">                                this.prefixLogMonitor, job.getAppDataJob()</span>
<span class="nc" id="L455">                                        .getProduct().getProductName());</span>
<span class="nc" id="L456">                        this.send(job);</span>
<span class="nc" id="L457">                        updateState(job, AppDataJobGenerationDtoState.SENT);</span>
<span class="nc" id="L458">                    } catch (AbstractCodedException e) {</span>
<span class="nc" id="L459">                        updateState(job, AppDataJobGenerationDtoState.READY);</span>
<span class="nc" id="L460">                        LOGGER.error(&quot;{} [productName {}] 3 - Job not send: {}&quot;,</span>
                                this.prefixLogMonitor, productName,
<span class="nc" id="L462">                                e.getLogMessage());</span>
<span class="nc" id="L463">                    }</span>
                }
<span class="nc" id="L465">            } catch (AbstractCodedException ace) {</span>
<span class="nc" id="L466">                LOGGER.error(</span>
                        &quot;{} [productName {}] [code ] Cannot generate job: {}&quot;,
                        this.prefixLogMonitor, productName,
<span class="nc" id="L469">                        ace.getCode().getCode(), ace.getLogMessage());</span>
<span class="nc" id="L470">            }</span>

<span class="nc" id="L472">            LOGGER.info(&quot;{} End&quot;, this.prefixLogMonitor);</span>
        }
<span class="fc" id="L474">    }</span>

    protected void updateState(JobGeneration&lt;T&gt; job,
            AppDataJobGenerationDtoState newState)
            throws AbstractCodedException {
<span class="nc" id="L479">        AppDataJobDto&lt;T&gt; modifiedJob = appDataService.patchTaskTableOfJob(</span>
<span class="nc" id="L480">                job.getAppDataJob().getIdentifier(),</span>
<span class="nc" id="L481">                job.getGeneration().getTaskTable(), newState);</span>
<span class="nc" id="L482">        job.updateAppDataJob(modifiedJob, taskTableXmlName);</span>

        // Log functional logs
<span class="nc" id="L485">        if (job.getGeneration()</span>
<span class="nc bnc" id="L486" title="All 2 branches missed.">                .getState() == AppDataJobGenerationDtoState.SENT) {</span>
<span class="nc bnc" id="L487" title="All 2 branches missed.">            if (newState == AppDataJobGenerationDtoState.SENT) {</span>
                // TODO addoutputs
<span class="nc" id="L489">                LOGGER.info(</span>
                        &quot;{} [REPORT] [s1pdgsTask {}JobGeneration] [subTask Generation] [STOP OK] [productName {}] Job generation successfully finished&quot;,
<span class="nc" id="L491">                        this.prefixLogMonitor, this.taskTable.getLevel(),</span>
<span class="nc" id="L492">                        job.getAppDataJob().getProduct().getProductName());</span>
            } else {
<span class="nc" id="L494">                LOGGER.error(</span>
                        &quot;{} [REPORT] [s1pdgsTask {}JobGeneration] [subTask Generation] [STOP KO] [productName {}] Job generation finished but job not sent&quot;,
<span class="nc" id="L496">                        this.prefixLogMonitor, this.taskTable.getLevel(),</span>
<span class="nc" id="L497">                        job.getAppDataJob().getProduct().getProductName());</span>
            }
        }
<span class="nc bnc" id="L500" title="All 2 branches missed.">        if (job.getAppDataJob().getState() == AppDataJobDtoState.TERMINATED) {</span>
<span class="nc" id="L501">            List&lt;String&gt; taskTables = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L502">            job.getAppDataJob().getGenerations().stream().forEach(gen -&gt; {</span>
<span class="nc" id="L503">                taskTables.add(gen.getTaskTable());</span>
<span class="nc" id="L504">            });</span>
<span class="nc" id="L505">            LOGGER.info(</span>
                    &quot;{} [REPORT] [s1pdgsTask {}JobGeneration] [STOP OK] [productName {}] [outputs {}] Job finished&quot;,
<span class="nc" id="L507">                    this.prefixLogMonitor, this.taskTable.getLevel(),</span>
<span class="nc" id="L508">                    job.getAppDataJob().getProduct().getProductName(),</span>
                    taskTables);
        }
<span class="nc" id="L511">    }</span>

    protected abstract void preSearch(JobGeneration&lt;T&gt; job)
            throws JobGenInputsMissingException;

    protected void inputsSearch(JobGeneration&lt;T&gt; job)
            throws JobGenInputsMissingException {
        // First, we evaluate each input query with no found file
<span class="nc" id="L519">        LOGGER.info(&quot;{} [productName {}] 2a - Requesting metadata&quot;,</span>
                this.prefixLogMonitor,
<span class="nc" id="L521">                job.getAppDataJob().getProduct().getProductName());</span>
<span class="nc" id="L522">        job.getMetadataQueries().forEach((k, v) -&gt; {</span>
<span class="nc bnc" id="L523" title="All 4 branches missed.">            if (v != null &amp;&amp; v.getResult() == null) {</span>
                try {
<span class="nc" id="L525">                    List&lt;SearchMetadata&gt; file = this.metadataService.search(</span>
<span class="nc" id="L526">                            v.getQuery(),</span>
<span class="nc" id="L527">                            job.getAppDataJob().getProduct().getStartTime(),</span>
<span class="nc" id="L528">                            job.getAppDataJob().getProduct().getStopTime(),</span>
<span class="nc" id="L529">                            job.getAppDataJob().getProduct().getSatelliteId(),</span>
<span class="nc" id="L530">                            job.getAppDataJob().getProduct().getInsConfId(),</span>
<span class="nc" id="L531">                            job.getAppDataJob().getProduct().getProcessMode());</span>
<span class="nc bnc" id="L532" title="All 2 branches missed.">                    if (file != null) {</span>
<span class="nc" id="L533">                        v.setResult(file);</span>
                    }
<span class="nc" id="L535">                } catch (JobGenMetadataException me) {</span>
<span class="nc" id="L536">                    LOGGER.warn(</span>
                            &quot;{} [productName {}] [alternative {}] Exception occurred when searching alternative: {}&quot;,
                            this.prefixLogMonitor,
<span class="nc" id="L539">                            job.getAppDataJob().getProduct().getProductName(),</span>
<span class="nc" id="L540">                            v.getQuery().toLogMessage(), me.getMessage());</span>
<span class="nc" id="L541">                }</span>
            }
<span class="nc" id="L543">        });</span>
<span class="nc" id="L544">        LOGGER.info(&quot;TESTLOGS results {}&quot;, job.getMetadataQueries());</span>

        // Second, for each task check if input is mandatory and if a file exist
<span class="nc" id="L547">        LOGGER.info(&quot;{} [productName {}] 2b - Try building inputs&quot;,</span>
                this.prefixLogMonitor,
<span class="nc" id="L549">                job.getAppDataJob().getProduct().getProductName());</span>
<span class="nc" id="L550">        int counterProc = 0;</span>
<span class="nc" id="L551">        Map&lt;String, JobOrderInput&gt; referenceInputs = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L552" title="All 2 branches missed.">        for (TaskTablePool pool : this.taskTable.getPools()) {</span>
<span class="nc bnc" id="L553" title="All 2 branches missed.">            for (TaskTableTask task : pool.getTasks()) {</span>
<span class="nc" id="L554">                Map&lt;String, String&gt; missingMetadata = new HashMap&lt;&gt;();</span>
<span class="nc" id="L555">                List&lt;JobOrderInput&gt; futureInputs = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L556" title="All 2 branches missed.">                for (TaskTableInput input : task.getInputs()) {</span>
                    // If it is a reference
<span class="nc bnc" id="L558" title="All 2 branches missed.">                    if (StringUtils.isEmpty(input.getReference())) {</span>

<span class="nc bnc" id="L560" title="All 2 branches missed.">                        if (ProductMode.isCompatibleWithTaskTableMode(this.mode,</span>
<span class="nc" id="L561">                                input.getMode())) {</span>
<span class="nc" id="L562">                            int currentOrder = 99;</span>
<span class="nc" id="L563">                            List&lt;JobOrderInput&gt; inputsToAdd = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L564" title="All 2 branches missed.">                            for (TaskTableInputAlternative alt : input</span>
<span class="nc" id="L565">                                    .getAlternatives()) {</span>
                                // We ignore input not DB
<span class="nc bnc" id="L567" title="All 2 branches missed.">                                if (alt.getOrigin() == TaskTableInputOrigin.DB) {</span>
<span class="nc" id="L568">                                    if (job.getMetadataQueries()</span>
<span class="nc" id="L569">                                            .get(alt.getIdSearchMetadataQuery())</span>
<span class="nc bnc" id="L570" title="All 2 branches missed.">                                            .getResult() != null) {</span>

<span class="nc" id="L572">                                        JobOrderFileNameType type =</span>
                                                JobOrderFileNameType.BLANK;
<span class="nc bnc" id="L574" title="All 4 branches missed.">                                        switch (alt.getFileNameType()) {</span>
                                            case PHYSICAL:
<span class="nc" id="L576">                                                type = JobOrderFileNameType.PHYSICAL;</span>
<span class="nc" id="L577">                                                break;</span>
                                            case DIRECTORY:
<span class="nc" id="L579">                                                type = JobOrderFileNameType.DIRECTORY;</span>
<span class="nc" id="L580">                                                break;</span>
                                            case REGEXP:
<span class="nc" id="L582">                                                type = JobOrderFileNameType.REGEXP;</span>
<span class="nc" id="L583">                                                break;</span>
                                            default:
                                                break;
                                        }

                                        // Retrieve family
<span class="nc" id="L589">                                        ProductFamily family =</span>
<span class="nc" id="L590">                                                ProductFamily.fromValue(</span>
                                                        this.jobGeneratorSettings
<span class="nc" id="L592">                                                                .getDefaultfamily());</span>
<span class="nc" id="L593">                                        if (this.jobGeneratorSettings</span>
<span class="nc bnc" id="L594" title="All 2 branches missed.">                                                .getInputfamilies().containsKey(</span>
<span class="nc" id="L595">                                                        alt.getFileType())) {</span>
<span class="nc" id="L596">                                            family = this.jobGeneratorSettings</span>
<span class="nc" id="L597">                                                    .getInputfamilies()</span>
<span class="nc" id="L598">                                                    .get(alt.getFileType());</span>
                                        }

                                        // Check order
<span class="nc" id="L602">                                        List&lt;JobOrderInputFile&gt; jobOrderInputFiles =</span>
<span class="nc" id="L603">                                                job.getMetadataQueries().get(alt</span>
<span class="nc" id="L604">                                                        .getIdSearchMetadataQuery())</span>
<span class="nc" id="L605">                                                        .getResult().stream()</span>
<span class="nc" id="L606">                                                        .map(file -&gt; new JobOrderInputFile(</span>
<span class="nc" id="L607">                                                                file.getProductName(),</span>
<span class="nc" id="L608">                                                                file.getKeyObjectStorage()))</span>
<span class="nc" id="L609">                                                        .collect(Collectors</span>
<span class="nc" id="L610">                                                                .toList());</span>
<span class="nc" id="L611">                                        List&lt;JobOrderTimeInterval&gt; jobOrderTimeIntervals =</span>
<span class="nc" id="L612">                                                job.getMetadataQueries().get(alt</span>
<span class="nc" id="L613">                                                        .getIdSearchMetadataQuery())</span>
<span class="nc" id="L614">                                                        .getResult().stream()</span>
<span class="nc" id="L615">                                                        .map(file -&gt; new JobOrderTimeInterval(</span>
<span class="nc" id="L616">                                                                file.getValidityStart(),</span>
<span class="nc" id="L617">                                                                file.getValidityStop(),</span>
<span class="nc" id="L618">                                                                file.getProductName(),</span>
                                                                SearchMetadata.DATE_FORMATTER))
<span class="nc" id="L620">                                                        .collect(Collectors</span>
<span class="nc" id="L621">                                                                .toList());</span>

<span class="nc bnc" id="L623" title="All 2 branches missed.">                                        if (currentOrder == alt.getOrder()) {</span>

<span class="nc" id="L625">                                            inputsToAdd.add(new JobOrderInput(</span>
<span class="nc" id="L626">                                                    alt.getFileType(), type,</span>
                                                    jobOrderInputFiles,
                                                    jobOrderTimeIntervals,
                                                    family));
<span class="nc" id="L630">                                        } else if (currentOrder &gt; alt</span>
<span class="nc bnc" id="L631" title="All 2 branches missed.">                                                .getOrder()) {</span>
<span class="nc" id="L632">                                            inputsToAdd = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L633">                                            inputsToAdd.add(new JobOrderInput(</span>
<span class="nc" id="L634">                                                    alt.getFileType(), type,</span>
                                                    jobOrderInputFiles,
                                                    jobOrderTimeIntervals,
                                                    family));
                                        }
                                        break;
                                    }
                                } else {
                                    // TODO set this general
<span class="nc" id="L643">                                    SimpleDateFormat format =</span>
                                            new SimpleDateFormat(
                                                    &quot;yyyyMMdd_HHmmssSSSSSS&quot;);
<span class="nc" id="L646">                                    String startDate = format.format(</span>
<span class="nc" id="L647">                                            job.getAppDataJob().getProduct()</span>
<span class="nc" id="L648">                                                    .getStartTime());</span>
<span class="nc" id="L649">                                    String stopDate = format.format(</span>
<span class="nc" id="L650">                                            job.getAppDataJob().getProduct()</span>
<span class="nc" id="L651">                                                    .getStopTime());</span>
<span class="nc" id="L652">                                    inputsToAdd.add(new JobOrderInput(</span>
<span class="nc" id="L653">                                            alt.getFileType(),</span>
                                            JobOrderFileNameType.REGEXP,
<span class="nc" id="L655">                                            Arrays.asList(new JobOrderInputFile(</span>
<span class="nc" id="L656">                                                    alt.getFileType(), &quot;&quot;)),</span>
<span class="nc" id="L657">                                            Arrays.asList(</span>
                                                    new JobOrderTimeInterval(
                                                            startDate, stopDate,
<span class="nc" id="L660">                                                            alt.getFileType(),</span>
                                                            DateTimeFormatter
<span class="nc" id="L662">                                                                    .ofPattern(</span>
                                                                            &quot;yyyyMMdd_HHmmssSSSSSS&quot;))),
                                            ProductFamily.BLANK));
                                }
<span class="nc" id="L666">                            }</span>
<span class="nc bnc" id="L667" title="All 2 branches missed.">                            if (!inputsToAdd.isEmpty()) {</span>
                                // We take a random one
<span class="nc" id="L669">                                int indexToTake = ThreadLocalRandom.current()</span>
<span class="nc" id="L670">                                        .nextInt(0, inputsToAdd.size());</span>
<span class="nc" id="L671">                                futureInputs.add(inputsToAdd.get(indexToTake));</span>
<span class="nc bnc" id="L672" title="All 2 branches missed.">                                if (!StringUtils.isEmpty(input.getId())) {</span>
<span class="nc" id="L673">                                    referenceInputs.put(input.getId(),</span>
<span class="nc" id="L674">                                            inputsToAdd.get(indexToTake));</span>
                                }

<span class="nc" id="L677">                            } else {</span>
<span class="nc" id="L678">                                if (input</span>
<span class="nc bnc" id="L679" title="All 2 branches missed.">                                        .getMandatory() == TaskTableMandatoryEnum.YES) {</span>
<span class="nc" id="L680">                                    missingMetadata.put(input.toLogMessage(),</span>
                                            &quot;&quot;);
                                }
                            }
<span class="nc" id="L684">                        }</span>
                    } else {
                        // We shall add inputs of the reference
<span class="nc bnc" id="L687" title="All 2 branches missed.">                        if (referenceInputs.containsKey(input.getReference())) {</span>
<span class="nc" id="L688">                            futureInputs.add(new JobOrderInput(</span>
<span class="nc" id="L689">                                    referenceInputs.get(input.getReference())));</span>
                        }
                    }
<span class="nc" id="L692">                }</span>
<span class="nc" id="L693">                counterProc++;</span>
<span class="nc bnc" id="L694" title="All 2 branches missed.">                if (missingMetadata.isEmpty()) {</span>
<span class="nc" id="L695">                    job.getJobOrder().getProcs().get(counterProc - 1)</span>
<span class="nc" id="L696">                            .setInputs(futureInputs);</span>
                } else {
<span class="nc" id="L698">                    throw new JobGenInputsMissingException(missingMetadata);</span>
                }
<span class="nc" id="L700">            }</span>
<span class="nc" id="L701">        }</span>
<span class="nc" id="L702">    }</span>

    protected void send(JobGeneration&lt;T&gt; job) throws AbstractCodedException {
<span class="nc" id="L705">        LOGGER.info(&quot;{} [productName {}] 3a - Building common job&quot;,</span>
                this.prefixLogMonitor,
<span class="nc" id="L707">                job.getAppDataJob().getProduct().getProductName());</span>
<span class="nc" id="L708">        int inc = INCREMENT_JOB.incrementAndGet();</span>
<span class="nc" id="L709">        String workingDir = &quot;/data/localWD/&quot; + inc + &quot;/&quot;;</span>

        // For each input and output of the job order, prefix by the working
        // directory
<span class="nc" id="L713">        job.getJobOrder().getProcs().stream()</span>
<span class="nc bnc" id="L714" title="All 2 branches missed.">                .filter(proc -&gt; proc != null</span>
<span class="nc bnc" id="L715" title="All 2 branches missed.">                        &amp;&amp; !CollectionUtils.isEmpty(proc.getInputs()))</span>
<span class="nc" id="L716">                .flatMap(proc -&gt; proc.getInputs().stream()).forEach(input -&gt; {</span>
<span class="nc" id="L717">                    input.getFilenames().forEach(filename -&gt; {</span>
<span class="nc" id="L718">                        filename.setFilename(</span>
<span class="nc" id="L719">                                workingDir + filename.getFilename());</span>
<span class="nc" id="L720">                    });</span>
<span class="nc" id="L721">                    input.getTimeIntervals().forEach(interval -&gt; {</span>
<span class="nc" id="L722">                        interval.setFileName(</span>
<span class="nc" id="L723">                                workingDir + interval.getFileName());</span>
<span class="nc" id="L724">                    });</span>
<span class="nc" id="L725">                });</span>
<span class="nc" id="L726">        job.getJobOrder().getProcs().stream()</span>
<span class="nc bnc" id="L727" title="All 2 branches missed.">                .filter(proc -&gt; proc != null</span>
<span class="nc bnc" id="L728" title="All 2 branches missed.">                        &amp;&amp; !CollectionUtils.isEmpty(proc.getOutputs()))</span>
<span class="nc" id="L729">                .flatMap(proc -&gt; proc.getOutputs().stream()).forEach(output -&gt; {</span>
<span class="nc" id="L730">                    output.setFileName(workingDir + output.getFileName());</span>
<span class="nc" id="L731">                });</span>

        // Apply implementation build job
<span class="nc" id="L734">        SimpleDateFormat dateFormat =</span>
                new SimpleDateFormat(JobOrderSensingTime.DATE_FORMAT);
<span class="nc" id="L736">        job.getJobOrder().getConf().setSensingTime(new JobOrderSensingTime(</span>
<span class="nc" id="L737">                dateFormat.format(</span>
<span class="nc" id="L738">                        job.getAppDataJob().getProduct().getStartTime()),</span>
<span class="nc" id="L739">                dateFormat.format(</span>
<span class="nc" id="L740">                        job.getAppDataJob().getProduct().getStopTime())));</span>

        // Custom Job order according implementation
<span class="nc" id="L743">        this.customJobOrder(job);</span>

        // Second, build the DTO
<span class="nc" id="L746">        String jobOrder = &quot;/data/localWD/&quot; + inc + &quot;/JobOrder.&quot; + inc + &quot;.xml&quot;;</span>
<span class="nc" id="L747">        ProductFamily family = ProductFamily.L0_JOB;</span>
<span class="nc bnc" id="L748" title="All 4 branches missed.">        switch (l0ProcessSettings.getLevel()) {</span>
            case L0:
<span class="nc" id="L750">                family = ProductFamily.L0_JOB;</span>
<span class="nc" id="L751">                break;</span>
            case L0_SEGMENT:
<span class="nc" id="L753">                family = ProductFamily.L0_SEGMENT_JOB;</span>
<span class="nc" id="L754">                break;</span>
            case L1:
<span class="nc" id="L756">                family = ProductFamily.L1_JOB;</span>
                break;
        }
<span class="nc" id="L759">        final LevelJobDto r = new LevelJobDto(family,</span>
<span class="nc" id="L760">                job.getAppDataJob().getProduct().getProductName(),</span>
<span class="nc" id="L761">                job.getAppDataJob().getProduct().getProcessMode(), workingDir,</span>
                jobOrder);

        try {

            // Add jobOrder inputs to the DTO
<span class="nc" id="L767">            List&lt;JobOrderInput&gt; distinctInputJobOrder = job.getJobOrder()</span>
<span class="nc" id="L768">                    .getProcs().stream()</span>
<span class="nc bnc" id="L769" title="All 2 branches missed.">                    .filter(proc -&gt; proc != null</span>
<span class="nc bnc" id="L770" title="All 2 branches missed.">                            &amp;&amp; !CollectionUtils.isEmpty(proc.getInputs()))</span>
<span class="nc" id="L771">                    .flatMap(proc -&gt; proc.getInputs().stream()).distinct()</span>
<span class="nc" id="L772">                    .collect(Collectors.toList());</span>
<span class="nc" id="L773">            r.addInputs(distinctInputJobOrder.stream()</span>
<span class="nc" id="L774">                    .map(input -&gt; new LevelJobInputDto(input.getFamily().name(),</span>
<span class="nc" id="L775">                            input.getFilenames().get(0).getFilename(),</span>
<span class="nc" id="L776">                            input.getFilenames().get(0).getKeyObjectStorage()))</span>
<span class="nc" id="L777">                    .collect(Collectors.toList()));</span>

            // Add the jobOrder itself in inputs
<span class="nc" id="L780">            r.addInput(new LevelJobInputDto(ProductFamily.JOB_ORDER.name(),</span>
                    jobOrder, xmlConverter
<span class="nc" id="L782">                            .convertFromObjectToXMLString(job.getJobOrder())));</span>

            // Add joborder output to the DTO
<span class="nc" id="L785">            List&lt;JobOrderOutput&gt; distinctOutputJobOrder = job.getJobOrder()</span>
<span class="nc" id="L786">                    .getProcs().stream()</span>
<span class="nc bnc" id="L787" title="All 2 branches missed.">                    .filter(proc -&gt; proc != null</span>
<span class="nc bnc" id="L788" title="All 2 branches missed.">                            &amp;&amp; !CollectionUtils.isEmpty(proc.getOutputs()))</span>
<span class="nc" id="L789">                    .flatMap(proc -&gt; proc.getOutputs().stream())</span>
<span class="nc" id="L790">                    .filter(output -&gt; output</span>
<span class="nc bnc" id="L791" title="All 2 branches missed.">                            .getFileNameType() == JobOrderFileNameType.REGEXP</span>
                            &amp;&amp; output
<span class="nc bnc" id="L793" title="All 2 branches missed.">                                    .getDestination() == JobOrderDestination.DB)</span>
<span class="nc" id="L794">                    .distinct().collect(Collectors.toList());</span>
<span class="nc" id="L795">            r.addOutputs(distinctOutputJobOrder.stream()</span>
<span class="nc" id="L796">                    .map(output -&gt; new LevelJobOutputDto(</span>
<span class="nc" id="L797">                            output.getFamily().name(), output.getFileName()))</span>
<span class="nc" id="L798">                    .collect(Collectors.toList()));</span>
<span class="nc" id="L799">            List&lt;JobOrderOutput&gt; distinctOutputJobOrderNotRegexp = job</span>
<span class="nc" id="L800">                    .getJobOrder().getProcs().stream()</span>
<span class="nc bnc" id="L801" title="All 2 branches missed.">                    .filter(proc -&gt; proc != null</span>
<span class="nc bnc" id="L802" title="All 2 branches missed.">                            &amp;&amp; !CollectionUtils.isEmpty(proc.getOutputs()))</span>
<span class="nc" id="L803">                    .flatMap(proc -&gt; proc.getOutputs().stream())</span>
<span class="nc" id="L804">                    .filter(output -&gt; output</span>
<span class="nc bnc" id="L805" title="All 2 branches missed.">                            .getFileNameType() == JobOrderFileNameType.DIRECTORY</span>
                            &amp;&amp; output
<span class="nc bnc" id="L807" title="All 2 branches missed.">                                    .getDestination() == JobOrderDestination.DB)</span>
<span class="nc" id="L808">                    .distinct().collect(Collectors.toList());</span>
<span class="nc" id="L809">            r.addOutputs(distinctOutputJobOrderNotRegexp</span>
<span class="nc" id="L810">                    .stream().map(</span>
<span class="nc" id="L811">                            output -&gt; new LevelJobOutputDto(</span>
<span class="nc" id="L812">                                    output.getFamily().name(),</span>
<span class="nc" id="L813">                                    output.getFileName() + &quot;^.*&quot;</span>
<span class="nc" id="L814">                                            + output.getFileType() + &quot;.*$&quot;))</span>
<span class="nc" id="L815">                    .collect(Collectors.toList()));</span>

            // Add the tasks
<span class="nc" id="L818">            this.tasks.forEach(pool -&gt; {</span>
<span class="nc" id="L819">                LevelJobPoolDto poolDto = new LevelJobPoolDto();</span>
<span class="nc" id="L820">                pool.forEach(task -&gt; {</span>
<span class="nc" id="L821">                    poolDto.addTask(new LevelJobTaskDto(task));</span>
<span class="nc" id="L822">                });</span>
<span class="nc" id="L823">                r.addPool(poolDto);</span>
<span class="nc" id="L824">            });</span>

            // Apply implementation build job
<span class="nc" id="L827">            LOGGER.info(&quot;{} [productName {}] 3b - Building custom job&quot;,</span>
                    this.prefixLogMonitor,
<span class="nc" id="L829">                    job.getAppDataJob().getProduct().getProductName());</span>
<span class="nc" id="L830">            this.customJobDto(job, r);</span>

<span class="nc" id="L832">        } catch (IOException | JAXBException e) {</span>
<span class="nc" id="L833">            throw new InternalErrorException(&quot;Cannot send the job&quot;, e);</span>
<span class="nc" id="L834">        }</span>

        // Thrid, send the job
<span class="nc" id="L837">        LOGGER.info(&quot;{} [productName {}] 3c - Publishing job&quot;,</span>
                this.prefixLogMonitor,
<span class="nc" id="L839">                job.getAppDataJob().getProduct().getProductName());</span>

<span class="nc" id="L841">        this.outputFactory.sendJob(job.getAppDataJob().getMessages().get(0), r);</span>
<span class="nc" id="L842">    }</span>

    protected abstract void customJobOrder(JobGeneration&lt;T&gt; job);

    protected abstract void customJobDto(JobGeneration&lt;T&gt; job, LevelJobDto dto);
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>