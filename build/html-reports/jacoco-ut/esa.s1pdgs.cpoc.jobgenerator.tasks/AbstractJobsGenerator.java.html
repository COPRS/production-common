<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>AbstractJobsGenerator.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Spring Boot Docker For Job Generator App</a> &gt; <a href="index.source.html" class="el_package">esa.s1pdgs.cpoc.jobgenerator.tasks</a> &gt; <span class="el_source">AbstractJobsGenerator.java</span></div><h1>AbstractJobsGenerator.java</h1><pre class="source lang-java linenums">package esa.s1pdgs.cpoc.jobgenerator.tasks;

import java.io.File;
import java.io.IOException;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ThreadLocalRandom;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

import javax.xml.bind.JAXBException;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.util.CollectionUtils;
import org.springframework.util.StringUtils;

import esa.s1pdgs.cpoc.appcatalog.client.job.AbstractAppCatalogJobService;
import esa.s1pdgs.cpoc.appcatalog.common.rest.model.job.AppDataJobDto;
import esa.s1pdgs.cpoc.appcatalog.common.rest.model.job.AppDataJobDtoState;
import esa.s1pdgs.cpoc.appcatalog.common.rest.model.job.AppDataJobGenerationDtoState;
import esa.s1pdgs.cpoc.appcatalog.common.rest.model.job.AppDataJobProductDto;
import esa.s1pdgs.cpoc.common.ProductFamily;
import esa.s1pdgs.cpoc.common.errors.AbstractCodedException;
import esa.s1pdgs.cpoc.common.errors.InternalErrorException;
import esa.s1pdgs.cpoc.common.errors.processing.JobGenBuildTaskTableException;
import esa.s1pdgs.cpoc.common.errors.processing.JobGenInputsMissingException;
import esa.s1pdgs.cpoc.common.errors.processing.JobGenMetadataException;
import esa.s1pdgs.cpoc.common.utils.DateUtils;
import esa.s1pdgs.cpoc.jobgenerator.config.JobGeneratorSettings;
import esa.s1pdgs.cpoc.jobgenerator.config.ProcessSettings;
import esa.s1pdgs.cpoc.jobgenerator.model.JobGeneration;
import esa.s1pdgs.cpoc.jobgenerator.model.ProductMode;
import esa.s1pdgs.cpoc.jobgenerator.model.converter.TaskTableToJobOrderConverter;
import esa.s1pdgs.cpoc.jobgenerator.model.joborder.JobOrder;
import esa.s1pdgs.cpoc.jobgenerator.model.joborder.JobOrderInput;
import esa.s1pdgs.cpoc.jobgenerator.model.joborder.JobOrderInputFile;
import esa.s1pdgs.cpoc.jobgenerator.model.joborder.JobOrderOutput;
import esa.s1pdgs.cpoc.jobgenerator.model.joborder.JobOrderSensingTime;
import esa.s1pdgs.cpoc.jobgenerator.model.joborder.JobOrderTimeInterval;
import esa.s1pdgs.cpoc.jobgenerator.model.joborder.enums.JobOrderDestination;
import esa.s1pdgs.cpoc.jobgenerator.model.joborder.enums.JobOrderFileNameType;
import esa.s1pdgs.cpoc.jobgenerator.model.metadata.AbstractMetadata;
import esa.s1pdgs.cpoc.jobgenerator.model.metadata.SearchMetadata;
import esa.s1pdgs.cpoc.jobgenerator.model.metadata.SearchMetadataQuery;
import esa.s1pdgs.cpoc.jobgenerator.model.metadata.SearchMetadataResult;
import esa.s1pdgs.cpoc.jobgenerator.model.tasktable.TaskTable;
import esa.s1pdgs.cpoc.jobgenerator.model.tasktable.TaskTableInput;
import esa.s1pdgs.cpoc.jobgenerator.model.tasktable.TaskTableInputAlternative;
import esa.s1pdgs.cpoc.jobgenerator.model.tasktable.TaskTablePool;
import esa.s1pdgs.cpoc.jobgenerator.model.tasktable.TaskTableTask;
import esa.s1pdgs.cpoc.jobgenerator.model.tasktable.enums.TaskTableInputOrigin;
import esa.s1pdgs.cpoc.jobgenerator.model.tasktable.enums.TaskTableMandatoryEnum;
import esa.s1pdgs.cpoc.jobgenerator.service.XmlConverter;
import esa.s1pdgs.cpoc.jobgenerator.service.metadata.MetadataService;
import esa.s1pdgs.cpoc.jobgenerator.service.mqi.OutputProducerFactory;
import esa.s1pdgs.cpoc.mqi.model.queue.LevelJobDto;
import esa.s1pdgs.cpoc.mqi.model.queue.LevelJobInputDto;
import esa.s1pdgs.cpoc.mqi.model.queue.LevelJobOutputDto;
import esa.s1pdgs.cpoc.mqi.model.queue.LevelJobPoolDto;
import esa.s1pdgs.cpoc.mqi.model.queue.LevelJobTaskDto;

/**
 * Class for processing product for a given task table
 * 
 * @author Cyrielle Gailliard
 */
public abstract class AbstractJobsGenerator&lt;T&gt; implements Runnable {

    /**
     * Logger
     */
<span class="fc" id="L77">    protected static final Logger LOGGER =</span>
<span class="fc" id="L78">            LogManager.getLogger(AbstractJobsGenerator.class);</span>

    /**
     * Use to generate an incremental id for locally upload session files
     */
<span class="fc" id="L83">    private static final AtomicInteger INCREMENT_JOB = new AtomicInteger(0);</span>

    /**
     * Producer in topic
     */
    private final OutputProducerFactory outputFactory;

    /**
     * XML converter
     */
    protected final XmlConverter xmlConverter;

    /**
     * 
     */
    protected final MetadataService metadataService;

    /**
     * 
     */
    protected final ProcessSettings l0ProcessSettings;

    protected final JobGeneratorSettings jobGeneratorSettings;

    /**
     * Applicative data service
     */
    private final AbstractAppCatalogJobService&lt;T&gt; appDataService;

    /**
     * Task table
     */
    protected String taskTableXmlName;
    protected TaskTable taskTable;
    protected List&lt;List&lt;String&gt;&gt; tasks;
    protected ProductMode mode;
    protected String prefixLogMonitor;
    protected String prefixLogMonitorRemove;

    /**
     * Template of job order. Contains all information except ones specific to
     * the session:
     * &lt;ul&gt;
     * &lt;li&gt;Inputs&lt;/li&gt;
     * &lt;li&gt;Configuration &gt; Sensing time&lt;/li&gt;
     * &lt;li&gt;Partial outputs: the work directory shall be put in front of each
     * filename&lt;/li&gt;
     * &lt;/ul&gt;
     */
    protected JobOrder jobOrderTemplate;

    /**
     * List of queries for metadata
     */
    protected final Map&lt;Integer, SearchMetadataQuery&gt; metadataSearchQueries;

    /**
     * Constructor
     * 
     * @param xmlConverter
     */
    public AbstractJobsGenerator(final XmlConverter xmlConverter,
            final MetadataService metadataService,
            final ProcessSettings l0ProcessSettings,
            final JobGeneratorSettings taskTablesSettings,
            final OutputProducerFactory outputFactory,
<span class="fc" id="L149">            final AbstractAppCatalogJobService&lt;T&gt; appDataService) {</span>
<span class="fc" id="L150">        this.xmlConverter = xmlConverter;</span>
<span class="fc" id="L151">        this.metadataService = metadataService;</span>
<span class="fc" id="L152">        this.l0ProcessSettings = l0ProcessSettings;</span>
<span class="fc" id="L153">        this.jobGeneratorSettings = taskTablesSettings;</span>
<span class="fc" id="L154">        this.metadataSearchQueries = new HashMap&lt;&gt;();</span>
<span class="fc" id="L155">        this.outputFactory = outputFactory;</span>
<span class="fc" id="L156">        this.tasks = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L157">        this.mode = ProductMode.BLANK;</span>
<span class="fc" id="L158">        this.appDataService = appDataService;</span>
<span class="fc" id="L159">    }</span>

    // ----------------------------------------------------
    // INITIALIZATION
    // ----------------------------------------------------

    /**
     * @param mode
     *            the mode to set
     */
    public void setMode(ProductMode mode) {
<span class="fc" id="L170">        this.mode = mode;</span>
<span class="fc" id="L171">    }</span>

    /**
     * Initialize the processor from the tasktable XML file
     * 
     * @param xmlFile
     */
    public void initialize(File xmlFile) throws JobGenBuildTaskTableException {

        // Build task table
<span class="fc" id="L181">        this.taskTableXmlName = xmlFile.getName();</span>
<span class="fc" id="L182">        this.buildTaskTable(xmlFile);</span>
<span class="fc" id="L183">        this.prefixLogMonitor =</span>
                &quot;[MONITOR] [step 3] [taskTable &quot; + this.taskTableXmlName + &quot;]&quot;;
<span class="fc" id="L185">        this.prefixLogMonitorRemove =</span>
                &quot;[MONITOR] [step 4] [taskTable &quot; + this.taskTableXmlName + &quot;]&quot;;

        // Build jobOrder
<span class="fc" id="L189">        this.buildJobOrderTemplate();</span>

        // Build list of metadata search query and linked to task table input
        // alternative
<span class="fc" id="L193">        this.buildMetadataSearchQuery();</span>

        // Build the tasks
<span class="fc" id="L196">        this.buildTasks();</span>

        // Retrieve list of inputs
<span class="fc" id="L199">        LOGGER.info(String.format(&quot;TaskTable %s initialized&quot;,</span>
<span class="fc" id="L200">                taskTable.getProcessorName()));</span>
<span class="fc" id="L201">    }</span>

    /**
     * Build the object TaskTable from XML file
     * 
     * @param xmlFile
     * @throws BuildTaskTableException
     */
    private void buildTaskTable(File xmlFile)
            throws JobGenBuildTaskTableException {
        // Retrieve task table
        try {
<span class="fc" id="L213">            this.taskTable = (TaskTable) xmlConverter</span>
<span class="fc" id="L214">                    .convertFromXMLToObject(xmlFile.getAbsolutePath());</span>
<span class="fc" id="L215">            this.taskTable.setLevel(this.l0ProcessSettings.getLevel());</span>
<span class="fc" id="L216">        } catch (IOException | JAXBException e) {</span>
<span class="fc" id="L217">            throw new JobGenBuildTaskTableException(this.taskTableXmlName,</span>
<span class="fc" id="L218">                    e.getMessage(), e);</span>
<span class="fc" id="L219">        }</span>
<span class="fc" id="L220">    }</span>

    private void buildJobOrderTemplate() {
        // Build from task table
<span class="fc" id="L224">        TaskTableToJobOrderConverter converter =</span>
                new TaskTableToJobOrderConverter();
<span class="fc" id="L226">        this.jobOrderTemplate = converter.apply(this.taskTable);</span>

        // Update values from configuration file
<span class="fc" id="L229">        this.jobOrderTemplate.getConf().getProcParams().forEach(item -&gt; {</span>
<span class="fc" id="L230">            if (this.l0ProcessSettings.getParams()</span>
<span class="fc bfc" id="L231" title="All 2 branches covered.">                    .containsKey(item.getName())) {</span>
<span class="fc" id="L232">                item.setValue(</span>
<span class="fc" id="L233">                        this.l0ProcessSettings.getParams().get(item.getName()));</span>
            }
<span class="fc" id="L235">        });</span>
<span class="fc" id="L236">        this.jobOrderTemplate.getConf()</span>
<span class="fc" id="L237">                .setStdoutLogLevel(this.l0ProcessSettings.getLoglevelstdout());</span>
<span class="fc" id="L238">        this.jobOrderTemplate.getConf()</span>
<span class="fc" id="L239">                .setStderrLogLevel(this.l0ProcessSettings.getLoglevelstderr());</span>
<span class="fc" id="L240">        this.jobOrderTemplate.getConf().setProcessingStation(</span>
<span class="fc" id="L241">                this.l0ProcessSettings.getProcessingstation());</span>

        // Update outputs from configuration file
<span class="fc" id="L244">        this.jobOrderTemplate.getProcs().stream()</span>
<span class="pc bpc" id="L245" title="1 of 2 branches missed.">                .filter(proc -&gt; !proc.getOutputs().isEmpty())</span>
<span class="fc" id="L246">                .flatMap(proc -&gt; proc.getOutputs().stream())</span>
<span class="fc" id="L247">                .filter(output -&gt; output</span>
<span class="fc bfc" id="L248" title="All 2 branches covered.">                        .getFileNameType() == JobOrderFileNameType.REGEXP)</span>
<span class="fc" id="L249">                .forEach(output -&gt; {</span>
<span class="fc" id="L250">                    if (this.l0ProcessSettings.getOutputregexps()</span>
<span class="fc bfc" id="L251" title="All 2 branches covered.">                            .containsKey(output.getFileType())) {</span>
<span class="fc" id="L252">                        output.setFileName(this.l0ProcessSettings</span>
<span class="fc" id="L253">                                .getOutputregexps().get(output.getFileType()));</span>
                    } else {
<span class="fc" id="L255">                        output.setFileName(</span>
<span class="fc" id="L256">                                &quot;^.*&quot; + output.getFileType() + &quot;.*$&quot;);</span>
                    }
<span class="fc" id="L258">                });</span>

        // Update the output family according configuration file
<span class="fc" id="L261">        this.jobOrderTemplate.getProcs().stream()</span>
<span class="pc bpc" id="L262" title="1 of 2 branches missed.">                .filter(proc -&gt; !proc.getOutputs().isEmpty())</span>
<span class="fc" id="L263">                .flatMap(proc -&gt; proc.getOutputs().stream()).forEach(output -&gt; {</span>
<span class="fc" id="L264">                    if (this.jobGeneratorSettings.getOutputfamilies()</span>
<span class="fc bfc" id="L265" title="All 2 branches covered.">                            .containsKey(output.getFileType())) {</span>
<span class="fc" id="L266">                        output.setFamily(this.jobGeneratorSettings</span>
<span class="fc" id="L267">                                .getOutputfamilies().get(output.getFileType()));</span>
                    } else {
<span class="fc" id="L269">                        output.setFamily(ProductFamily.fromValue(</span>
<span class="fc" id="L270">                                this.jobGeneratorSettings.getDefaultfamily()));</span>
                    }
<span class="fc" id="L272">                });</span>
<span class="fc" id="L273">    }</span>

    private void buildMetadataSearchQuery() {
<span class="fc" id="L276">        final AtomicInteger counter = new AtomicInteger(0);</span>
<span class="fc" id="L277">        this.taskTable.getPools().stream()</span>
<span class="pc bpc" id="L278" title="1 of 2 branches missed.">                .filter(pool -&gt; !CollectionUtils.isEmpty(pool.getTasks()))</span>
<span class="fc" id="L279">                .flatMap(pool -&gt; pool.getTasks().stream())</span>
<span class="pc bpc" id="L280" title="1 of 2 branches missed.">                .filter(task -&gt; !CollectionUtils.isEmpty(task.getInputs()))</span>
<span class="fc" id="L281">                .flatMap(task -&gt; task.getInputs().stream())</span>
<span class="fc" id="L282">                .filter(input -&gt; !CollectionUtils</span>
<span class="fc bfc" id="L283" title="All 2 branches covered.">                        .isEmpty(input.getAlternatives()))</span>
<span class="fc" id="L284">                .flatMap(input -&gt; input.getAlternatives().stream())</span>
<span class="fc bfc" id="L285" title="All 2 branches covered.">                .filter(alt -&gt; alt.getOrigin() == TaskTableInputOrigin.DB)</span>
<span class="fc" id="L286">                .collect(Collectors.groupingBy(</span>
                        TaskTableInputAlternative::getTaskTableInputAltKey))
<span class="fc" id="L288">                .forEach((k, v) -&gt; {</span>
<span class="fc" id="L289">                    String fileType = k.getFileType();</span>
<span class="fc" id="L290">                    if (this.jobGeneratorSettings.getMapTypeMeta()</span>
<span class="fc bfc" id="L291" title="All 2 branches covered.">                            .containsKey(k.getFileType())) {</span>
<span class="fc" id="L292">                        fileType = this.jobGeneratorSettings.getMapTypeMeta()</span>
<span class="fc" id="L293">                                .get(k.getFileType());</span>
                    }
<span class="fc" id="L295">                    ProductFamily family = ProductFamily.BLANK;</span>
<span class="fc" id="L296">                    if (this.jobGeneratorSettings.getInputfamilies()</span>
<span class="fc bfc" id="L297" title="All 2 branches covered.">                            .containsKey(fileType)) {</span>
<span class="fc" id="L298">                        family = this.jobGeneratorSettings.getInputfamilies()</span>
<span class="fc" id="L299">                                .get(fileType);</span>
                    }
<span class="fc" id="L301">                    SearchMetadataQuery query =</span>
<span class="fc" id="L302">                            new SearchMetadataQuery(counter.incrementAndGet(),</span>
<span class="fc" id="L303">                                    k.getRetrievalMode(), k.getDeltaTime0(),</span>
<span class="fc" id="L304">                                    k.getDeltaTime1(), fileType, family);</span>
<span class="fc" id="L305">                    this.metadataSearchQueries.put(counter.get(), query);</span>
<span class="fc" id="L306">                    v.forEach(alt -&gt; {</span>
<span class="fc" id="L307">                        alt.setIdSearchMetadataQuery(counter.get());</span>
<span class="fc" id="L308">                    });</span>
<span class="fc" id="L309">                });</span>
<span class="fc" id="L310">    }</span>

    protected void buildTasks() {
<span class="fc" id="L313">        this.taskTable.getPools().forEach(pool -&gt; {</span>
<span class="fc" id="L314">            this.tasks.add(</span>
<span class="fc" id="L315">                    pool.getTasks().stream().map(TaskTableTask::getFileName)</span>
<span class="fc" id="L316">                            .collect(Collectors.toList()));</span>
<span class="fc" id="L317">        });</span>
<span class="fc" id="L318">    }</span>

    // ----------------------------------------------------
    // JOB GENERATION
    // ----------------------------------------------------

    @Override
    public void run() {
<span class="fc" id="L326">        JobGeneration&lt;T&gt; job = null;</span>

        // Get a job to generate
        try {
<span class="fc" id="L330">            List&lt;AppDataJobDto&lt;T&gt;&gt; jobs = appDataService</span>
<span class="fc" id="L331">                    .findNByPodAndGenerationTaskTableWithNotSentGeneration(</span>
<span class="fc" id="L332">                            l0ProcessSettings.getHostname(), taskTableXmlName);</span>
            // Determine job to process
<span class="fc bfc" id="L334" title="All 2 branches covered.">            if (CollectionUtils.isEmpty(jobs)) {</span>
<span class="fc" id="L335">                job = null;</span>
            } else {
<span class="fc bfc" id="L337" title="All 2 branches covered.">                for (AppDataJobDto&lt;T&gt; appDataJob : jobs) {</span>
                    // Check if we can do a loop
<span class="fc" id="L339">                    long currentTimestamp = System.currentTimeMillis();</span>
<span class="fc" id="L340">                    boolean todo = false;</span>
<span class="fc" id="L341">                    job = new JobGeneration&lt;&gt;(appDataJob, taskTableXmlName);</span>
<span class="pc bpc" id="L342" title="1 of 3 branches missed.">                    switch (job.getGeneration().getState()) {</span>
                        case INITIAL:
<span class="fc bfc" id="L344" title="All 2 branches covered.">                            if (job.getGeneration().getLastUpdateDate() == null</span>
<span class="fc" id="L345">                                    || job.getGeneration().getLastUpdateDate()</span>
<span class="fc" id="L346">                                            .getTime() &lt; currentTimestamp</span>
                                                    - jobGeneratorSettings
<span class="fc" id="L348">                                                            .getWaitprimarycheck()</span>
<span class="pc bpc" id="L349" title="1 of 2 branches missed.">                                                            .getTempo()) {</span>
<span class="fc" id="L350">                                todo = true;</span>
                            }
                            break;
                        case PRIMARY_CHECK:
<span class="fc" id="L354">                            if (job.getGeneration().getLastUpdateDate()</span>
<span class="fc" id="L355">                                    .getTime() &lt; currentTimestamp</span>
                                            - jobGeneratorSettings
<span class="fc" id="L357">                                                    .getWaitmetadatainput()</span>
<span class="pc bpc" id="L358" title="1 of 2 branches missed.">                                                    .getTempo()) {</span>
<span class="nc" id="L359">                                todo = true;</span>
                            }
                            break;
                        default:
<span class="nc" id="L363">                            todo = true;</span>
                            break;
                    }
<span class="fc bfc" id="L366" title="All 2 branches covered.">                    if (todo) {</span>
<span class="fc" id="L367">                        job.setJobOrder(new JobOrder(this.jobOrderTemplate,</span>
<span class="fc" id="L368">                                this.l0ProcessSettings.getLevel()));</span>
<span class="fc bfc" id="L369" title="All 2 branches covered.">                        for (Integer key : metadataSearchQueries.keySet()) {</span>
<span class="fc" id="L370">                            SearchMetadataQuery query =</span>
<span class="fc" id="L371">                                    metadataSearchQueries.get(key);</span>
<span class="fc" id="L372">                            job.getMetadataQueries().put(key,</span>
                                    new SearchMetadataResult(
                                            new SearchMetadataQuery(query)));
<span class="fc" id="L375">                        }</span>
<span class="fc" id="L376">                        break;</span>
                    } else {
<span class="fc" id="L378">                        job = null;</span>
                    }
<span class="fc" id="L380">                }</span>
            }
<span class="fc" id="L382">        } catch (AbstractCodedException ace) {</span>
<span class="fc" id="L383">            LOGGER.error(&quot;{} CAnnot retrieve the current jobs: {}&quot;,</span>
<span class="fc" id="L384">                    this.prefixLogMonitor, ace.getLogMessage());</span>
<span class="fc" id="L385">        }</span>

<span class="fc bfc" id="L387" title="All 2 branches covered.">        if (job != null) {</span>
<span class="fc" id="L388">            String productName =</span>
<span class="fc" id="L389">                    job.getAppDataJob().getProduct().getProductName();</span>

            try {
<span class="fc" id="L392">                LOGGER.debug(</span>
                        &quot;{} [productName {}] [status {}] Trying job generation&quot;,
                        this.prefixLogMonitor, productName,
<span class="fc" id="L395">                        job.getGeneration().getState());</span>

                // Check primary input
<span class="fc" id="L398">                if (job.getGeneration()</span>
<span class="pc bpc" id="L399" title="1 of 2 branches missed.">                        .getState() == AppDataJobGenerationDtoState.INITIAL) {</span>
                    try {
<span class="pc bpc" id="L401" title="1 of 2 branches missed.">                        if (job.getGeneration().getNbErrors() == 0) {</span>
<span class="fc" id="L402">                            LOGGER.info(</span>
                                    &quot;{} [REPORT] [s1pdgsTask {}JobGeneration] [subTask Generation] [START] [productName {}] [inputs {}] Trying job generation&quot;,
                                    this.prefixLogMonitor,
<span class="fc" id="L405">                                    this.taskTable.getLevel(), productName,</span>
<span class="fc" id="L406">                                    job.getGeneration().getTaskTable());</span>
                        }
<span class="fc" id="L408">                        LOGGER.info(</span>
                                &quot;{} [productName {}] 1 - Checking the pre-requirements&quot;,
                                this.prefixLogMonitor, productName);
<span class="fc" id="L411">                        this.preSearch(job);</span>
<span class="fc" id="L412">                        AppDataJobDto&lt;T&gt; modifiedJob = appDataService.patchJob(</span>
<span class="fc" id="L413">                                job.getAppDataJob().getIdentifier(),</span>
<span class="fc" id="L414">                                job.getAppDataJob(), false, true, false);</span>
<span class="fc" id="L415">                        job.setAppDataJob(modifiedJob);</span>
<span class="fc" id="L416">                        updateState(job,</span>
                                AppDataJobGenerationDtoState.PRIMARY_CHECK);
<span class="nc" id="L418">                    } catch (AbstractCodedException e) {</span>
<span class="nc" id="L419">                        updateState(job, AppDataJobGenerationDtoState.INITIAL);</span>
<span class="nc" id="L420">                        LOGGER.error(</span>
                                &quot;{} [productName {}] 1 - Pre-requirements not checked: {}&quot;,
                                this.prefixLogMonitor, productName,
<span class="nc" id="L423">                                e.getLogMessage());</span>
<span class="fc" id="L424">                    }</span>
                }

                // Search input
<span class="fc" id="L428">                if (job.getGeneration()</span>
<span class="pc bpc" id="L429" title="1 of 2 branches missed.">                        .getState() == AppDataJobGenerationDtoState.PRIMARY_CHECK) {</span>
                    try {
<span class="fc" id="L431">                        LOGGER.info(&quot;{} [productName {}] 2 - Searching inputs&quot;,</span>
<span class="fc" id="L432">                                this.prefixLogMonitor, job.getAppDataJob()</span>
<span class="fc" id="L433">                                        .getProduct().getProductName());</span>
<span class="fc" id="L434">                        this.inputsSearch(job);</span>
<span class="fc" id="L435">                        updateState(job, AppDataJobGenerationDtoState.READY);</span>
<span class="nc" id="L436">                    } catch (AbstractCodedException e) {</span>
<span class="nc" id="L437">                        updateState(job,</span>
                                AppDataJobGenerationDtoState.PRIMARY_CHECK);
<span class="nc" id="L439">                        LOGGER.error(</span>
                                &quot;{} [productName {}] 2 - Inputs not found: {}&quot;,
                                this.prefixLogMonitor, productName,
<span class="nc" id="L442">                                e.getLogMessage());</span>
<span class="fc" id="L443">                    }</span>
                }

                // Prepare and send job if ready
<span class="fc" id="L447">                if (job.getGeneration()</span>
<span class="pc bpc" id="L448" title="1 of 2 branches missed.">                        .getState() == AppDataJobGenerationDtoState.READY) {</span>
                    try {
<span class="fc" id="L450">                        LOGGER.info(&quot;{} [productName {}] 2 - Searching inputs&quot;,</span>
<span class="fc" id="L451">                                this.prefixLogMonitor, job.getAppDataJob()</span>
<span class="fc" id="L452">                                        .getProduct().getProductName());</span>
<span class="fc" id="L453">                        this.inputsSearch(job);</span>
<span class="fc" id="L454">                        LOGGER.info(&quot;{} [productName {}] 3 - Sending job&quot;,</span>
<span class="fc" id="L455">                                this.prefixLogMonitor, job.getAppDataJob()</span>
<span class="fc" id="L456">                                        .getProduct().getProductName());</span>
<span class="fc" id="L457">                        this.send(job);</span>
<span class="fc" id="L458">                        updateState(job, AppDataJobGenerationDtoState.SENT);</span>
<span class="nc" id="L459">                    } catch (AbstractCodedException e) {</span>
<span class="nc" id="L460">                        updateState(job, AppDataJobGenerationDtoState.READY);</span>
<span class="nc" id="L461">                        LOGGER.error(&quot;{} [productName {}] 3 - Job not send: {}&quot;,</span>
                                this.prefixLogMonitor, productName,
<span class="nc" id="L463">                                e.getLogMessage());</span>
<span class="fc" id="L464">                    }</span>
                }
<span class="nc" id="L466">            } catch (AbstractCodedException ace) {</span>
<span class="nc" id="L467">                LOGGER.error(</span>
                        &quot;{} [productName {}] [code ] Cannot generate job: {}&quot;,
                        this.prefixLogMonitor, productName,
<span class="nc" id="L470">                        ace.getCode().getCode(), ace.getLogMessage());</span>
<span class="fc" id="L471">            }</span>

<span class="fc" id="L473">            LOGGER.info(&quot;{} End&quot;, this.prefixLogMonitor);</span>
        }
<span class="fc" id="L475">    }</span>

    protected void updateState(JobGeneration&lt;T&gt; job,
            AppDataJobGenerationDtoState newState)
            throws AbstractCodedException {
<span class="fc" id="L480">        AppDataJobDto&lt;T&gt; modifiedJob = appDataService.patchTaskTableOfJob(</span>
<span class="fc" id="L481">                job.getAppDataJob().getIdentifier(),</span>
<span class="fc" id="L482">                job.getGeneration().getTaskTable(), newState);</span>
<span class="fc" id="L483">        job.updateAppDataJob(modifiedJob, taskTableXmlName);</span>

        // Log functional logs
<span class="fc" id="L486">        if (job.getGeneration()</span>
<span class="fc bfc" id="L487" title="All 2 branches covered.">                .getState() == AppDataJobGenerationDtoState.SENT) {</span>
<span class="pc bpc" id="L488" title="1 of 2 branches missed.">            if (newState == AppDataJobGenerationDtoState.SENT) {</span>
                // TODO addoutputs
<span class="fc" id="L490">                LOGGER.info(</span>
                        &quot;{} [REPORT] [s1pdgsTask {}JobGeneration] [subTask Generation] [STOP OK] [productName {}] Job generation successfully finished&quot;,
<span class="fc" id="L492">                        this.prefixLogMonitor, this.taskTable.getLevel(),</span>
<span class="fc" id="L493">                        job.getAppDataJob().getProduct().getProductName());</span>
            } else {
<span class="nc" id="L495">                LOGGER.error(</span>
                        &quot;{} [REPORT] [s1pdgsTask {}JobGeneration] [subTask Generation] [STOP KO] [productName {}] Job generation finished but job not sent&quot;,
<span class="nc" id="L497">                        this.prefixLogMonitor, this.taskTable.getLevel(),</span>
<span class="nc" id="L498">                        job.getAppDataJob().getProduct().getProductName());</span>
            }
        }
<span class="pc bpc" id="L501" title="1 of 2 branches missed.">        if (job.getAppDataJob().getState() == AppDataJobDtoState.TERMINATED) {</span>
<span class="nc" id="L502">            List&lt;String&gt; taskTables = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L503">            job.getAppDataJob().getGenerations().stream().forEach(gen -&gt; {</span>
<span class="nc" id="L504">                taskTables.add(gen.getTaskTable());</span>
<span class="nc" id="L505">            });</span>
<span class="nc" id="L506">            LOGGER.info(</span>
                    &quot;{} [REPORT] [s1pdgsTask {}JobGeneration] [STOP OK] [productName {}] [outputs {}] Job finished&quot;,
<span class="nc" id="L508">                    this.prefixLogMonitor, this.taskTable.getLevel(),</span>
<span class="nc" id="L509">                    job.getAppDataJob().getProduct().getProductName(),</span>
                    taskTables);
        }
<span class="fc" id="L512">    }</span>

    protected abstract void preSearch(JobGeneration&lt;T&gt; job)
            throws JobGenInputsMissingException;

    protected void inputsSearch(JobGeneration&lt;T&gt; job)
            throws JobGenInputsMissingException {
        // First, we evaluate each input query with no found file
<span class="fc" id="L520">        LOGGER.info(&quot;{} [productName {}] 2a - Requesting metadata&quot;,</span>
                this.prefixLogMonitor,
<span class="fc" id="L522">                job.getAppDataJob().getProduct().getProductName());</span>
<span class="fc" id="L523">        job.getMetadataQueries().forEach((k, v) -&gt; {</span>
<span class="pc bpc" id="L524" title="1 of 4 branches missed.">            if (v != null &amp;&amp; v.getResult() == null) {</span>
                try {
<span class="fc" id="L526">                    List&lt;SearchMetadata&gt; file =</span>
<span class="fc" id="L527">                            this.metadataService.search(v.getQuery(),</span>
<span class="fc" id="L528">                                    DateUtils.convertToAnotherFormat(</span>
<span class="fc" id="L529">                                            job.getAppDataJob().getProduct()</span>
<span class="fc" id="L530">                                                    .getStartTime(),</span>
                                            AppDataJobProductDto.TIME_FORMATTER,
                                            AbstractMetadata.DATE_FORMATTER),
<span class="fc" id="L533">                                    DateUtils.convertToAnotherFormat(</span>
<span class="fc" id="L534">                                            job.getAppDataJob().getProduct()</span>
<span class="fc" id="L535">                                                    .getStopTime(),</span>
                                            AppDataJobProductDto.TIME_FORMATTER,
                                            AbstractMetadata.DATE_FORMATTER),
<span class="fc" id="L538">                                    job.getAppDataJob().getProduct()</span>
<span class="fc" id="L539">                                            .getSatelliteId(),</span>
<span class="fc" id="L540">                                    job.getAppDataJob().getProduct()</span>
<span class="fc" id="L541">                                            .getInsConfId(),</span>
<span class="fc" id="L542">                                    job.getAppDataJob().getProduct()</span>
<span class="fc" id="L543">                                            .getProcessMode());</span>
<span class="fc bfc" id="L544" title="All 2 branches covered.">                    if (file != null) {</span>
<span class="fc" id="L545">                        v.setResult(file);</span>
                    }
<span class="nc" id="L547">                } catch (JobGenMetadataException me) {</span>
<span class="nc" id="L548">                    LOGGER.warn(</span>
                            &quot;{} [productName {}] [alternative {}] Exception occurred when searching alternative: {}&quot;,
                            this.prefixLogMonitor,
<span class="nc" id="L551">                            job.getAppDataJob().getProduct().getProductName(),</span>
<span class="nc" id="L552">                            v.getQuery().toLogMessage(), me.getMessage());</span>
<span class="fc" id="L553">                }</span>
            }
<span class="fc" id="L555">        });</span>
<span class="pc bpc" id="L556" title="1 of 2 branches missed.">        if (LOGGER.isDebugEnabled()) {</span>
<span class="fc" id="L557">            LOGGER.debug(&quot;Search metadata queries {}&quot;,</span>
<span class="fc" id="L558">                    job.getMetadataQueries());</span>
        }

        // Second, for each task check if input is mandatory and if a file exist
<span class="fc" id="L562">        LOGGER.info(&quot;{} [productName {}] 2b - Try building inputs&quot;,</span>
                this.prefixLogMonitor,
<span class="fc" id="L564">                job.getAppDataJob().getProduct().getProductName());</span>
<span class="fc" id="L565">        int counterProc = 0;</span>
<span class="fc" id="L566">        Map&lt;String, JobOrderInput&gt; referenceInputs = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L567" title="All 2 branches covered.">        for (TaskTablePool pool : this.taskTable.getPools()) {</span>
<span class="fc bfc" id="L568" title="All 2 branches covered.">            for (TaskTableTask task : pool.getTasks()) {</span>
<span class="fc" id="L569">                Map&lt;String, String&gt; missingMetadata = new HashMap&lt;&gt;();</span>
<span class="fc" id="L570">                List&lt;JobOrderInput&gt; futureInputs = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L571" title="All 2 branches covered.">                for (TaskTableInput input : task.getInputs()) {</span>
                    // If it is a reference
<span class="fc bfc" id="L573" title="All 2 branches covered.">                    if (StringUtils.isEmpty(input.getReference())) {</span>

<span class="fc bfc" id="L575" title="All 2 branches covered.">                        if (ProductMode.isCompatibleWithTaskTableMode(this.mode,</span>
<span class="fc" id="L576">                                input.getMode())) {</span>
<span class="fc" id="L577">                            int currentOrder = 99;</span>
<span class="fc" id="L578">                            List&lt;JobOrderInput&gt; inputsToAdd = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L579" title="All 2 branches covered.">                            for (TaskTableInputAlternative alt : input</span>
<span class="fc" id="L580">                                    .getAlternatives()) {</span>
                                // We ignore input not DB
<span class="fc bfc" id="L582" title="All 2 branches covered.">                                if (alt.getOrigin() == TaskTableInputOrigin.DB) {</span>
<span class="fc bfc" id="L583" title="All 2 branches covered.">                                    if (!CollectionUtils.isEmpty(job</span>
<span class="fc" id="L584">                                            .getMetadataQueries()</span>
<span class="fc" id="L585">                                            .get(alt.getIdSearchMetadataQuery())</span>
<span class="fc" id="L586">                                            .getResult())) {</span>

<span class="fc" id="L588">                                        JobOrderFileNameType type =</span>
                                                JobOrderFileNameType.BLANK;
<span class="pc bpc" id="L590" title="3 of 4 branches missed.">                                        switch (alt.getFileNameType()) {</span>
                                            case PHYSICAL:
<span class="fc" id="L592">                                                type = JobOrderFileNameType.PHYSICAL;</span>
<span class="fc" id="L593">                                                break;</span>
                                            case DIRECTORY:
<span class="nc" id="L595">                                                type = JobOrderFileNameType.DIRECTORY;</span>
<span class="nc" id="L596">                                                break;</span>
                                            case REGEXP:
<span class="nc" id="L598">                                                type = JobOrderFileNameType.REGEXP;</span>
<span class="nc" id="L599">                                                break;</span>
                                            default:
                                                break;
                                        }

                                        // Retrieve family
<span class="fc" id="L605">                                        ProductFamily family =</span>
<span class="fc" id="L606">                                                ProductFamily.fromValue(</span>
                                                        this.jobGeneratorSettings
<span class="fc" id="L608">                                                                .getDefaultfamily());</span>
<span class="fc" id="L609">                                        if (this.jobGeneratorSettings</span>
<span class="fc bfc" id="L610" title="All 2 branches covered.">                                                .getInputfamilies().containsKey(</span>
<span class="fc" id="L611">                                                        alt.getFileType())) {</span>
<span class="fc" id="L612">                                            family = this.jobGeneratorSettings</span>
<span class="fc" id="L613">                                                    .getInputfamilies()</span>
<span class="fc" id="L614">                                                    .get(alt.getFileType());</span>
                                        }

                                        // Check order
<span class="fc" id="L618">                                        List&lt;JobOrderInputFile&gt; jobOrderInputFiles =</span>
<span class="fc" id="L619">                                                job.getMetadataQueries().get(alt</span>
<span class="fc" id="L620">                                                        .getIdSearchMetadataQuery())</span>
<span class="fc" id="L621">                                                        .getResult().stream()</span>
<span class="fc" id="L622">                                                        .map(file -&gt; new JobOrderInputFile(</span>
<span class="fc" id="L623">                                                                file.getProductName(),</span>
<span class="fc" id="L624">                                                                file.getKeyObjectStorage()))</span>
<span class="fc" id="L625">                                                        .collect(Collectors</span>
<span class="fc" id="L626">                                                                .toList());</span>
<span class="fc" id="L627">                                        List&lt;JobOrderTimeInterval&gt; jobOrderTimeIntervals =</span>
<span class="fc" id="L628">                                                job.getMetadataQueries().get(alt</span>
<span class="fc" id="L629">                                                        .getIdSearchMetadataQuery())</span>
<span class="fc" id="L630">                                                        .getResult().stream()</span>
<span class="fc" id="L631">                                                        .map(file -&gt; new JobOrderTimeInterval(</span>
                                                                DateUtils
<span class="fc" id="L633">                                                                        .convertToAnotherFormat(</span>
<span class="fc" id="L634">                                                                                file.getValidityStart(),</span>
<span class="fc" id="L635">                                                                                file.getStartTimeFormatter(),</span>
                                                                                JobOrderTimeInterval.DATE_FORMATTER),
                                                                DateUtils
<span class="fc" id="L638">                                                                        .convertToAnotherFormat(</span>
<span class="fc" id="L639">                                                                                file.getValidityStop(),</span>
<span class="fc" id="L640">                                                                                file.getStopTimeFormatter(),</span>
                                                                                JobOrderTimeInterval.DATE_FORMATTER),
<span class="fc" id="L642">                                                                file.getProductName()))</span>
<span class="fc" id="L643">                                                        .collect(Collectors</span>
<span class="fc" id="L644">                                                                .toList());</span>

<span class="pc bpc" id="L646" title="1 of 2 branches missed.">                                        if (currentOrder == alt.getOrder()) {</span>

<span class="nc" id="L648">                                            inputsToAdd.add(new JobOrderInput(</span>
<span class="nc" id="L649">                                                    alt.getFileType(), type,</span>
                                                    jobOrderInputFiles,
                                                    jobOrderTimeIntervals,
                                                    family));
<span class="fc" id="L653">                                        } else if (currentOrder &gt; alt</span>
<span class="pc bpc" id="L654" title="1 of 2 branches missed.">                                                .getOrder()) {</span>
<span class="fc" id="L655">                                            inputsToAdd = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L656">                                            inputsToAdd.add(new JobOrderInput(</span>
<span class="fc" id="L657">                                                    alt.getFileType(), type,</span>
                                                    jobOrderInputFiles,
                                                    jobOrderTimeIntervals,
                                                    family));
                                        }
                                        break;
                                    }
                                } else {
<span class="fc" id="L665">                                    DateTimeFormatter outFormatter =</span>
<span class="fc" id="L666">                                            DateTimeFormatter.ofPattern(</span>
                                                    &quot;yyyyMMdd_HHmmssSSSSSS&quot;);
<span class="fc" id="L668">                                    String startDate =</span>
<span class="fc" id="L669">                                            DateUtils.convertToAnotherFormat(</span>
<span class="fc" id="L670">                                                    job.getAppDataJob()</span>
<span class="fc" id="L671">                                                            .getProduct()</span>
<span class="fc" id="L672">                                                            .getStartTime(),</span>
                                                    AppDataJobProductDto.TIME_FORMATTER,
                                                    outFormatter);
<span class="fc" id="L675">                                    String stopDate =</span>
<span class="fc" id="L676">                                            DateUtils.convertToAnotherFormat(</span>
<span class="fc" id="L677">                                                    job.getAppDataJob()</span>
<span class="fc" id="L678">                                                            .getProduct()</span>
<span class="fc" id="L679">                                                            .getStopTime(),</span>
                                                    AppDataJobProductDto.TIME_FORMATTER,
                                                    outFormatter);
<span class="fc" id="L682">                                    String filename = alt.getFileType();</span>
<span class="fc" id="L683">                                    if (this.jobGeneratorSettings</span>
<span class="fc" id="L684">                                            .getMapTypeMeta()</span>
<span class="pc bpc" id="L685" title="1 of 2 branches missed.">                                            .containsKey(alt.getFileType())) {</span>
<span class="nc" id="L686">                                        filename = this.jobGeneratorSettings</span>
<span class="nc" id="L687">                                                .getMapTypeMeta()</span>
<span class="nc" id="L688">                                                .get(alt.getFileType());</span>
                                    }
<span class="fc" id="L690">                                    inputsToAdd.add(new JobOrderInput(</span>
<span class="fc" id="L691">                                            alt.getFileType(),</span>
                                            JobOrderFileNameType.REGEXP,
<span class="fc" id="L693">                                            Arrays.asList(new JobOrderInputFile(</span>
                                                    filename, &quot;&quot;)),
<span class="fc" id="L695">                                            Arrays.asList(</span>
                                                    new JobOrderTimeInterval(
                                                            startDate, stopDate,
                                                            filename,
                                                            outFormatter)),
                                            ProductFamily.BLANK));
                                }
<span class="fc" id="L702">                            }</span>
<span class="fc bfc" id="L703" title="All 2 branches covered.">                            if (!inputsToAdd.isEmpty()) {</span>
                                // We take a random one
<span class="fc" id="L705">                                int indexToTake = ThreadLocalRandom.current()</span>
<span class="fc" id="L706">                                        .nextInt(0, inputsToAdd.size());</span>
<span class="fc" id="L707">                                futureInputs.add(inputsToAdd.get(indexToTake));</span>
<span class="fc bfc" id="L708" title="All 2 branches covered.">                                if (!StringUtils.isEmpty(input.getId())) {</span>
<span class="fc" id="L709">                                    referenceInputs.put(input.getId(),</span>
<span class="fc" id="L710">                                            inputsToAdd.get(indexToTake));</span>
                                }

<span class="fc" id="L713">                            } else {</span>
<span class="fc" id="L714">                                if (input</span>
<span class="pc bpc" id="L715" title="1 of 2 branches missed.">                                        .getMandatory() == TaskTableMandatoryEnum.YES) {</span>
<span class="nc" id="L716">                                    missingMetadata.put(input.toLogMessage(),</span>
                                            &quot;&quot;);
                                }
                            }
<span class="fc" id="L720">                        }</span>
                    } else {
                        // We shall add inputs of the reference
<span class="fc bfc" id="L723" title="All 2 branches covered.">                        if (referenceInputs.containsKey(input.getReference())) {</span>
<span class="fc" id="L724">                            futureInputs.add(new JobOrderInput(</span>
<span class="fc" id="L725">                                    referenceInputs.get(input.getReference())));</span>
                        }
                    }
<span class="fc" id="L728">                }</span>
<span class="fc" id="L729">                counterProc++;</span>
<span class="pc bpc" id="L730" title="1 of 2 branches missed.">                if (missingMetadata.isEmpty()) {</span>
<span class="fc" id="L731">                    job.getJobOrder().getProcs().get(counterProc - 1)</span>
<span class="fc" id="L732">                            .setInputs(futureInputs);</span>
                } else {
<span class="nc" id="L734">                    throw new JobGenInputsMissingException(missingMetadata);</span>
                }
<span class="fc" id="L736">            }</span>
<span class="fc" id="L737">        }</span>
<span class="fc" id="L738">    }</span>

    protected void send(JobGeneration&lt;T&gt; job) throws AbstractCodedException {
<span class="fc" id="L741">        LOGGER.info(&quot;{} [productName {}] 3a - Building common job&quot;,</span>
                this.prefixLogMonitor,
<span class="fc" id="L743">                job.getAppDataJob().getProduct().getProductName());</span>
<span class="fc" id="L744">        int inc = INCREMENT_JOB.incrementAndGet();</span>
<span class="fc" id="L745">        String workingDir = &quot;/data/localWD/&quot; + inc + &quot;/&quot;;</span>

        // For each input and output of the job order, prefix by the working
        // directory
<span class="fc" id="L749">        job.getJobOrder().getProcs().stream()</span>
<span class="pc bpc" id="L750" title="1 of 2 branches missed.">                .filter(proc -&gt; proc != null</span>
<span class="pc bpc" id="L751" title="1 of 2 branches missed.">                        &amp;&amp; !CollectionUtils.isEmpty(proc.getInputs()))</span>
<span class="fc" id="L752">                .flatMap(proc -&gt; proc.getInputs().stream()).forEach(input -&gt; {</span>
<span class="fc" id="L753">                    input.getFilenames().forEach(filename -&gt; {</span>
<span class="fc" id="L754">                        filename.setFilename(</span>
<span class="fc" id="L755">                                workingDir + filename.getFilename());</span>
<span class="fc" id="L756">                    });</span>
<span class="fc" id="L757">                    input.getTimeIntervals().forEach(interval -&gt; {</span>
<span class="fc" id="L758">                        interval.setFileName(</span>
<span class="fc" id="L759">                                workingDir + interval.getFileName());</span>
<span class="fc" id="L760">                    });</span>
<span class="fc" id="L761">                });</span>
<span class="fc" id="L762">        job.getJobOrder().getProcs().stream()</span>
<span class="pc bpc" id="L763" title="1 of 2 branches missed.">                .filter(proc -&gt; proc != null</span>
<span class="pc bpc" id="L764" title="1 of 2 branches missed.">                        &amp;&amp; !CollectionUtils.isEmpty(proc.getOutputs()))</span>
<span class="fc" id="L765">                .flatMap(proc -&gt; proc.getOutputs().stream()).forEach(output -&gt; {</span>
<span class="fc" id="L766">                    output.setFileName(workingDir + output.getFileName());</span>
<span class="fc" id="L767">                });</span>

        // Apply implementation build job
<span class="fc" id="L770">        job.getJobOrder().getConf()</span>
<span class="fc" id="L771">                .setSensingTime(new JobOrderSensingTime(</span>
<span class="fc" id="L772">                        DateUtils.convertToAnotherFormat(</span>
<span class="fc" id="L773">                                job.getAppDataJob().getProduct().getStartTime(),</span>
                                AppDataJobProductDto.TIME_FORMATTER,
                                JobOrderSensingTime.DATETIME_FORMATTER),

<span class="fc" id="L777">                        DateUtils.convertToAnotherFormat(</span>
<span class="fc" id="L778">                                job.getAppDataJob().getProduct().getStopTime(),</span>
                                AppDataJobProductDto.TIME_FORMATTER,
                                JobOrderSensingTime.DATETIME_FORMATTER)));

        // Custom Job order according implementation
<span class="fc" id="L783">        this.customJobOrder(job);</span>

        // Second, build the DTO
<span class="fc" id="L786">        String jobOrder = &quot;/data/localWD/&quot; + inc + &quot;/JobOrder.&quot; + inc + &quot;.xml&quot;;</span>
<span class="fc" id="L787">        ProductFamily family = ProductFamily.L0_JOB;</span>
<span class="pc bpc" id="L788" title="2 of 4 branches missed.">        switch (l0ProcessSettings.getLevel()) {</span>
            case L0:
<span class="fc" id="L790">                family = ProductFamily.L0_JOB;</span>
<span class="fc" id="L791">                break;</span>
            case L0_SEGMENT:
<span class="nc" id="L793">                family = ProductFamily.L0_SEGMENT_JOB;</span>
<span class="nc" id="L794">                break;</span>
            case L1:
<span class="fc" id="L796">                family = ProductFamily.L1_JOB;</span>
                break;
        }
<span class="fc" id="L799">        final LevelJobDto r = new LevelJobDto(family,</span>
<span class="fc" id="L800">                job.getAppDataJob().getProduct().getProductName(),</span>
<span class="fc" id="L801">                job.getAppDataJob().getProduct().getProcessMode(), workingDir,</span>
                jobOrder);

        try {

            // Add jobOrder inputs to the DTO
<span class="fc" id="L807">            List&lt;JobOrderInput&gt; distinctInputJobOrder = job.getJobOrder()</span>
<span class="fc" id="L808">                    .getProcs().stream()</span>
<span class="pc bpc" id="L809" title="1 of 2 branches missed.">                    .filter(proc -&gt; proc != null</span>
<span class="pc bpc" id="L810" title="1 of 2 branches missed.">                            &amp;&amp; !CollectionUtils.isEmpty(proc.getInputs()))</span>
<span class="fc" id="L811">                    .flatMap(proc -&gt; proc.getInputs().stream()).distinct()</span>
<span class="fc" id="L812">                    .collect(Collectors.toList());</span>
<span class="fc" id="L813">            distinctInputJobOrder.forEach(input -&gt; {</span>
<span class="fc bfc" id="L814" title="All 2 branches covered.">                for (JobOrderInputFile file : input.getFilenames()) {</span>
<span class="fc" id="L815">                    r.addInput(new LevelJobInputDto(input.getFamily().name(),</span>
<span class="fc" id="L816">                            file.getFilename(), file.getKeyObjectStorage()));</span>
<span class="fc" id="L817">                }</span>
<span class="fc" id="L818">            });</span>

            // Add the jobOrder itself in inputs
<span class="fc" id="L821">            r.addInput(new LevelJobInputDto(ProductFamily.JOB_ORDER.name(),</span>
                    jobOrder, xmlConverter
<span class="fc" id="L823">                            .convertFromObjectToXMLString(job.getJobOrder())));</span>

            // Add joborder output to the DTO
<span class="fc" id="L826">            List&lt;JobOrderOutput&gt; distinctOutputJobOrder = job.getJobOrder()</span>
<span class="fc" id="L827">                    .getProcs().stream()</span>
<span class="pc bpc" id="L828" title="1 of 2 branches missed.">                    .filter(proc -&gt; proc != null</span>
<span class="pc bpc" id="L829" title="1 of 2 branches missed.">                            &amp;&amp; !CollectionUtils.isEmpty(proc.getOutputs()))</span>
<span class="fc" id="L830">                    .flatMap(proc -&gt; proc.getOutputs().stream())</span>
<span class="fc" id="L831">                    .filter(output -&gt; output</span>
<span class="fc bfc" id="L832" title="All 2 branches covered.">                            .getFileNameType() == JobOrderFileNameType.REGEXP</span>
                            &amp;&amp; output
<span class="pc bpc" id="L834" title="1 of 2 branches missed.">                                    .getDestination() == JobOrderDestination.DB)</span>
<span class="fc" id="L835">                    .distinct().collect(Collectors.toList());</span>
<span class="fc" id="L836">            r.addOutputs(distinctOutputJobOrder.stream()</span>
<span class="pc" id="L837">                    .map(output -&gt; new LevelJobOutputDto(</span>
<span class="nc" id="L838">                            output.getFamily().name(), output.getFileName()))</span>
<span class="fc" id="L839">                    .collect(Collectors.toList()));</span>
<span class="fc" id="L840">            List&lt;JobOrderOutput&gt; distinctOutputJobOrderNotRegexp = job</span>
<span class="fc" id="L841">                    .getJobOrder().getProcs().stream()</span>
<span class="pc bpc" id="L842" title="1 of 2 branches missed.">                    .filter(proc -&gt; proc != null</span>
<span class="pc bpc" id="L843" title="1 of 2 branches missed.">                            &amp;&amp; !CollectionUtils.isEmpty(proc.getOutputs()))</span>
<span class="fc" id="L844">                    .flatMap(proc -&gt; proc.getOutputs().stream())</span>
<span class="fc" id="L845">                    .filter(output -&gt; output</span>
<span class="fc bfc" id="L846" title="All 2 branches covered.">                            .getFileNameType() == JobOrderFileNameType.DIRECTORY</span>
                            &amp;&amp; output
<span class="fc bfc" id="L848" title="All 2 branches covered.">                                    .getDestination() == JobOrderDestination.DB)</span>
<span class="fc" id="L849">                    .distinct().collect(Collectors.toList());</span>
<span class="fc" id="L850">            r.addOutputs(distinctOutputJobOrderNotRegexp</span>
<span class="fc" id="L851">                    .stream().map(</span>
<span class="fc" id="L852">                            output -&gt; new LevelJobOutputDto(</span>
<span class="fc" id="L853">                                    output.getFamily().name(),</span>
<span class="fc" id="L854">                                    output.getFileName() + &quot;^.*&quot;</span>
<span class="fc" id="L855">                                            + output.getFileType() + &quot;.*$&quot;))</span>
<span class="fc" id="L856">                    .collect(Collectors.toList()));</span>

            // Add the tasks
<span class="fc" id="L859">            this.tasks.forEach(pool -&gt; {</span>
<span class="fc" id="L860">                LevelJobPoolDto poolDto = new LevelJobPoolDto();</span>
<span class="fc" id="L861">                pool.forEach(task -&gt; {</span>
<span class="fc" id="L862">                    poolDto.addTask(new LevelJobTaskDto(task));</span>
<span class="fc" id="L863">                });</span>
<span class="fc" id="L864">                r.addPool(poolDto);</span>
<span class="fc" id="L865">            });</span>

            // Apply implementation build job
<span class="fc" id="L868">            LOGGER.info(&quot;{} [productName {}] 3b - Building custom job&quot;,</span>
                    this.prefixLogMonitor,
<span class="fc" id="L870">                    job.getAppDataJob().getProduct().getProductName());</span>
<span class="fc" id="L871">            this.customJobDto(job, r);</span>

<span class="nc" id="L873">        } catch (IOException | JAXBException e) {</span>
<span class="nc" id="L874">            throw new InternalErrorException(&quot;Cannot send the job&quot;, e);</span>
<span class="fc" id="L875">        }</span>

        // Thrid, send the job
<span class="fc" id="L878">        LOGGER.info(&quot;{} [productName {}] 3c - Publishing job&quot;,</span>
                this.prefixLogMonitor,
<span class="fc" id="L880">                job.getAppDataJob().getProduct().getProductName());</span>

<span class="fc" id="L882">        this.outputFactory.sendJob(job.getAppDataJob().getMessages().get(0), r);</span>
<span class="fc" id="L883">    }</span>

    protected abstract void customJobOrder(JobGeneration&lt;T&gt; job);

    protected abstract void customJobDto(JobGeneration&lt;T&gt; job, LevelJobDto dto);
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>