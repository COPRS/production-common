<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JobProcessor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">S1-PDGS Cloud POC - Wrapper</a> &gt; <a href="index.source.html" class="el_package">esa.s1pdgs.cpoc.wrapper.job</a> &gt; <span class="el_source">JobProcessor.java</span></div><h1>JobProcessor.java</h1><pre class="source lang-java linenums">package esa.s1pdgs.cpoc.wrapper.job;

import java.io.File;
import java.io.IOException;
import java.nio.file.FileVisitOption;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Comparator;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorCompletionService;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;

import esa.s1pdgs.cpoc.common.ApplicationLevel;
import esa.s1pdgs.cpoc.common.errors.AbstractCodedException;
import esa.s1pdgs.cpoc.common.errors.AbstractCodedException.ErrorCode;
import esa.s1pdgs.cpoc.common.errors.InternalErrorException;
import esa.s1pdgs.cpoc.mqi.client.GenericMqiService;
import esa.s1pdgs.cpoc.mqi.client.StatusService;
import esa.s1pdgs.cpoc.mqi.model.queue.LevelJobDto;
import esa.s1pdgs.cpoc.mqi.model.rest.Ack;
import esa.s1pdgs.cpoc.mqi.model.rest.AckMessageDto;
import esa.s1pdgs.cpoc.mqi.model.rest.GenericMessageDto;
import esa.s1pdgs.cpoc.wrapper.config.ApplicationProperties;
import esa.s1pdgs.cpoc.wrapper.config.DevProperties;
import esa.s1pdgs.cpoc.wrapper.job.file.InputDownloader;
import esa.s1pdgs.cpoc.wrapper.job.file.OutputProcessor;
import esa.s1pdgs.cpoc.wrapper.job.mqi.OutputProcuderFactory;
import esa.s1pdgs.cpoc.wrapper.job.obs.ObsService;
import esa.s1pdgs.cpoc.wrapper.job.process.PoolExecutorCallable;
import esa.s1pdgs.cpoc.wrapper.status.AppStatus;

/**
 * Process a jobs
 * &lt;li&gt;Launch in a thread the processes execution which will wait for being
 * active once the minimal inputs are download&lt;/li&gt;
 * &lt;li&gt;Create necessary directories and files, download inputs and inform
 * process executor when it can start&lt;/li&gt;
 * &lt;li&gt;Wait for processes execution end&lt;/li&gt;
 * &lt;li&gt;Process outputs&lt;/li&gt;
 * 
 * @author Viveris Technologies
 */
@Service
public class JobProcessor {

    /**
     * Logger
     */
<span class="fc" id="L60">    private static final Logger LOGGER =</span>
<span class="fc" id="L61">            LogManager.getLogger(JobProcessor.class);</span>

    /**
     * Application status
     */
    private final AppStatus appStatus;

    /**
     * Development properties
     */
    private final DevProperties devProperties;

    /**
     * Application properties
     */
    private final ApplicationProperties properties;

    /**
     * Output processsor
     */
    private final OutputProcuderFactory procuderFactory;

    /**
     * Output processsor
     */
    private final ObsService obsService;

    /**
     * MQI service for reading message
     */
    private final GenericMqiService&lt;LevelJobDto&gt; mqiService;

    /**
     * MQI service for stopping the MQI
     */
    private final StatusService mqiStatusService;

    /**
     * @param job
     * @param appStatus
     * @param properties
     * @param devProperties
     * @param kafkaContainerId
     * @param kafkaRegistry
     * @param obsService
     * @param procuderFactory
     * @param outputListFile
     */
    @Autowired
    public JobProcessor(final AppStatus appStatus,
            final ApplicationProperties properties,
            final DevProperties devProperties, final ObsService obsService,
            final OutputProcuderFactory procuderFactory,
            @Qualifier(&quot;mqiServiceForLevelJobs&quot;) final GenericMqiService&lt;LevelJobDto&gt; mqiService,
<span class="fc" id="L115">            @Qualifier(&quot;mqiServiceForStatus&quot;) final StatusService mqiStatusService) {</span>
<span class="fc" id="L116">        this.appStatus = appStatus;</span>
<span class="fc" id="L117">        this.devProperties = devProperties;</span>
<span class="fc" id="L118">        this.properties = properties;</span>
<span class="fc" id="L119">        this.obsService = obsService;</span>
<span class="fc" id="L120">        this.procuderFactory = procuderFactory;</span>
<span class="fc" id="L121">        this.mqiService = mqiService;</span>
<span class="fc" id="L122">        this.mqiStatusService = mqiStatusService;</span>
<span class="fc" id="L123">    }</span>

    /**
     * Consume and execute jobs
     */
    @Scheduled(fixedDelayString = &quot;${process.fixed-delay-ms}&quot;, initialDelayString = &quot;${process.init-delay-poll-ms}&quot;)
    public void processJob() {

        // ----------------------------------------------------------
        // Read Message
        // ----------------------------------------------------------
<span class="fc" id="L134">        LOGGER.trace(&quot;[MONITOR] [step 0] Waiting message&quot;);</span>
<span class="fc bfc" id="L135" title="All 2 branches covered.">        if (appStatus.isShallBeStopped()) {</span>
<span class="fc" id="L136">            LOGGER.info(&quot;[MONITOR] [step 0] The wrapper shall be stopped&quot;);</span>
<span class="fc" id="L137">            this.appStatus.forceStopping();</span>
<span class="fc" id="L138">            return;</span>
        }
<span class="fc" id="L140">        GenericMessageDto&lt;LevelJobDto&gt; message = null;</span>
        try {
<span class="fc" id="L142">            message = mqiService.next();</span>
<span class="fc" id="L143">        } catch (AbstractCodedException ace) {</span>
<span class="fc" id="L144">            LOGGER.error(&quot;[MONITOR] [step 0] [code {}] {}&quot;,</span>
<span class="fc" id="L145">                    ace.getCode().getCode(), ace.getLogMessage());</span>
<span class="fc" id="L146">            message = null;</span>
<span class="fc" id="L147">            this.appStatus.setError(&quot;NEXT_MESSAGE&quot;);</span>
<span class="fc" id="L148">        }</span>
<span class="pc bpc" id="L149" title="1 of 4 branches missed.">        if (message == null || message.getBody() == null) {</span>
<span class="fc" id="L150">            LOGGER.trace(&quot;[MONITOR] [step 0] No message received: continue&quot;);</span>
<span class="fc" id="L151">            return;</span>
        }
<span class="fc" id="L153">        appStatus.setProcessing(message.getIdentifier());</span>
<span class="fc" id="L154">        LOGGER.info(&quot;Initializing job processing {}&quot;, message);</span>

        // ----------------------------------------------------------
        // Initialize processing
        // ------------------------------------------------------
<span class="fc" id="L159">        LevelJobDto job = message.getBody();</span>
<span class="fc" id="L160">        LOGGER.info(&quot;[REPORT] [s1pdgsTask {}Processing] [subTask messageProcessing] {} [productName {}] [START] Start L0 Job generation&quot;,</span>
<span class="fc" id="L161">        		properties.getLevel(), getPrefixMonitorLog(MonitorLogUtils.LOG_READ, job), job.getProductIdentifier());</span>
<span class="fc" id="L162">        File workdir = new File(job.getWorkDirectory());</span>
        // Remove working directory if exist
<span class="pc bpc" id="L164" title="1 of 2 branches missed.">        if (workdir.exists()) {</span>
<span class="fc" id="L165">            this.eraseDirectory(job);</span>
        }
        // Build output list
<span class="fc" id="L168">        String outputListFile =</span>
<span class="fc" id="L169">                job.getWorkDirectory() + workdir.getName() + &quot;.LIST&quot;;</span>
<span class="pc bpc" id="L170" title="1 of 2 branches missed.">        if (properties.getLevel() == ApplicationLevel.L0) {</span>
<span class="fc" id="L171">            outputListFile = job.getWorkDirectory() + &quot;AIOProc.LIST&quot;;</span>
        }
        // Initialize the pool processor executor
<span class="fc" id="L174">        PoolExecutorCallable procExecutor = new PoolExecutorCallable(properties,</span>
<span class="fc" id="L175">                job, getPrefixMonitorLog(MonitorLogUtils.LOG_PROCESS, job), this.properties.getLevel());</span>
<span class="fc" id="L176">        ExecutorService procExecutorSrv = Executors.newSingleThreadExecutor();</span>
<span class="fc" id="L177">        ExecutorCompletionService&lt;Boolean&gt; procCompletionSrv =</span>
                new ExecutorCompletionService&lt;&gt;(procExecutorSrv);
        // Initialize the input downloader
<span class="fc" id="L180">        InputDownloader inputDownloader =</span>
<span class="fc" id="L181">                new InputDownloader(obsService, job.getWorkDirectory(),</span>
<span class="fc" id="L182">                        job.getInputs(), this.properties.getSizeBatchDownload(),</span>
<span class="fc" id="L183">                        getPrefixMonitorLog(MonitorLogUtils.LOG_INPUT, job),</span>
<span class="fc" id="L184">                        procExecutor, this.properties.getLevel());</span>
        // Initiliaze the output processor
<span class="fc" id="L186">        OutputProcessor outputProcessor =</span>
                new OutputProcessor(obsService, procuderFactory, message,
<span class="fc" id="L188">                        outputListFile, this.properties.getSizeBatchUpload(),</span>
<span class="fc" id="L189">                        getPrefixMonitorLog(MonitorLogUtils.LOG_OUTPUT, job), this.properties.getLevel());</span>

        // ----------------------------------------------------------
        // Process message
        // ----------------------------------------------------------
<span class="fc" id="L194">        processJob(message, inputDownloader, outputProcessor, procExecutorSrv,</span>
                procCompletionSrv, procExecutor);

<span class="fc" id="L197">        LOGGER.info(&quot;[REPORT] [s1pdgsTask {}Processing] [subTask messageProcessing] {} [productName {}] [STOP OK] End L0 job generation&quot;,</span>
<span class="fc" id="L198">        		properties.getLevel(), getPrefixMonitorLog(MonitorLogUtils.LOG_END, job), job.getProductIdentifier());</span>

<span class="fc" id="L200">    }</span>

    /**
     * Get the prefix for monitor logs according the step for this class
     * instance
     * 
     * @param step
     * @return
     */
    protected String getPrefixMonitorLog(final String step,
            final LevelJobDto job) {
<span class="fc" id="L211">        return MonitorLogUtils.getPrefixMonitorLog(step, job);</span>
    }

    /**
     * @param job
     * @param inputDownloader
     * @param outputProcessor
     * @param procExecutorSrv
     * @param procCompletionSrv
     * @param procExecutor
     */
    protected void processJob(final GenericMessageDto&lt;LevelJobDto&gt; message,
            final InputDownloader inputDownloader,
            final OutputProcessor outputProcessor,
            final ExecutorService procExecutorSrv,
            final ExecutorCompletionService&lt;Boolean&gt; procCompletionSrv,
            final PoolExecutorCallable procExecutor) {
<span class="fc" id="L228">        boolean poolProcessing = false;</span>
<span class="fc" id="L229">        LevelJobDto job = message.getBody();</span>
<span class="fc" id="L230">        int step = 0;</span>
<span class="fc" id="L231">        boolean ackOk = false;</span>
<span class="fc" id="L232">        String errorMessage = &quot;&quot;;</span>
        try {
<span class="fc" id="L234">            step = 3;</span>
<span class="fc" id="L235">            LOGGER.info(&quot;{} Starting process executor&quot;,</span>
<span class="fc" id="L236">                    getPrefixMonitorLog(MonitorLogUtils.LOG_PROCESS, job));</span>
<span class="fc" id="L237">            procCompletionSrv.submit(procExecutor);</span>
<span class="fc" id="L238">            poolProcessing = true;</span>

<span class="fc" id="L240">            step = 2;</span>
<span class="fc bfc" id="L241" title="All 2 branches covered.">            if (devProperties.getStepsActivation().get(&quot;download&quot;)) {</span>
<span class="fc" id="L242">                checkThreadInterrupted();</span>
<span class="fc" id="L243">                LOGGER.info(&quot;{} Preparing local working directory&quot;,</span>
<span class="fc" id="L244">                        getPrefixMonitorLog(MonitorLogUtils.LOG_INPUT, job));</span>
<span class="fc" id="L245">                inputDownloader.processInputs();</span>
            } else {
<span class="fc" id="L247">                LOGGER.info(&quot;{} Preparing local working directory bypassed&quot;,</span>
<span class="fc" id="L248">                        getPrefixMonitorLog(MonitorLogUtils.LOG_INPUT, job));</span>
            }

<span class="fc" id="L251">            step = 3;</span>
<span class="fc" id="L252">            this.waitForPoolProcessesEnding(procCompletionSrv);</span>
<span class="fc" id="L253">            poolProcessing = false;</span>

<span class="fc" id="L255">            step = 4;</span>
<span class="fc bfc" id="L256" title="All 2 branches covered.">            if (devProperties.getStepsActivation().get(&quot;upload&quot;)) {</span>
<span class="fc" id="L257">                checkThreadInterrupted();</span>
<span class="fc" id="L258">                LOGGER.info(&quot;{} Processing l0 outputs&quot;,</span>
<span class="fc" id="L259">                        getPrefixMonitorLog(MonitorLogUtils.LOG_OUTPUT, job));</span>
<span class="fc" id="L260">                outputProcessor.processOutput();</span>
            } else {
<span class="fc" id="L262">                LOGGER.info(&quot;{} Processing l0 outputs bypasssed&quot;,</span>
<span class="fc" id="L263">                        getPrefixMonitorLog(MonitorLogUtils.LOG_OUTPUT, job));</span>
            }
<span class="fc" id="L265">            ackOk = true;</span>

<span class="fc" id="L267">        } catch (AbstractCodedException ace) {</span>
<span class="fc" id="L268">            ackOk = false;</span>
<span class="fc" id="L269">            errorMessage = String.format(&quot;[REPORT] [s1pdgsTask %sProcessing] [subTask processing] [STOP KO] %s [step %d] %s [code %d] %s&quot;,</span>
<span class="fc" id="L270">            		properties.getLevel(),</span>
<span class="fc" id="L271">                    getPrefixMonitorLog(MonitorLogUtils.LOG_DFT, job), step,</span>
<span class="fc" id="L272">                    getPrefixMonitorLog(MonitorLogUtils.LOG_ERROR, job),</span>
<span class="fc" id="L273">                    ace.getCode().getCode(), ace.getLogMessage());</span>
<span class="nc" id="L274">        } catch (InterruptedException e) {</span>
<span class="nc" id="L275">            ackOk = false;</span>
<span class="nc" id="L276">            errorMessage = String.format(</span>
                    &quot;[REPORT] %s [step %d] %s [code %d] [s1pdgsTask %sProcessing] [STOP KO] [subTask processing] [msg interrupted exception]&quot;,
<span class="nc" id="L278">                    getPrefixMonitorLog(MonitorLogUtils.LOG_DFT, job), step,</span>
<span class="nc" id="L279">                    getPrefixMonitorLog(MonitorLogUtils.LOG_ERROR, job),</span>
<span class="nc" id="L280">                    ErrorCode.INTERNAL_ERROR.getCode(),</span>
<span class="nc" id="L281">                    properties.getLevel());</span>
        } finally {
<span class="fc" id="L283">            cleanJobProcessing(job, poolProcessing, procExecutorSrv);</span>
        }

        // Ack and check if application shall stopped
<span class="fc" id="L287">        ackProcessing(message, ackOk, errorMessage);</span>
<span class="fc" id="L288">    }</span>

    /**
     * Check if thread interrupted
     * 
     * @throws InterruptedException
     */
    protected void checkThreadInterrupted() throws InterruptedException {
<span class="pc bpc" id="L296" title="1 of 2 branches missed.">        if (Thread.currentThread().isInterrupted()) {</span>
<span class="nc" id="L297">            throw new InterruptedException(&quot;Current thread is interrupted&quot;);</span>
        }
<span class="fc" id="L299">    }</span>

    /**
     * Wait for the processes execution completion
     * 
     * @throws InterruptedException
     * @throws AbstractCodedException
     */
    protected void waitForPoolProcessesEnding(
            final ExecutorCompletionService&lt;Boolean&gt; procCompletionSrv)
            throws InterruptedException, AbstractCodedException {
<span class="fc" id="L310">        checkThreadInterrupted();</span>
        try {
<span class="fc" id="L312">            procCompletionSrv.take().get(properties.getTmProcAllTasksS(),</span>
                    TimeUnit.SECONDS);
<span class="fc" id="L314">        } catch (ExecutionException e) {</span>
<span class="fc bfc" id="L315" title="All 2 branches covered.">            if (e.getCause() instanceof AbstractCodedException) {</span>
<span class="fc" id="L316">                throw (AbstractCodedException) e.getCause();</span>
            } else {
<span class="fc" id="L318">                throw new InternalErrorException(e.getMessage(), e);</span>
            }
<span class="nc" id="L320">        } catch (TimeoutException e) {</span>
<span class="nc" id="L321">            throw new InternalErrorException(e.getMessage(), e);</span>
<span class="fc" id="L322">        }</span>
<span class="fc" id="L323">    }</span>

    /**
     * @param job
     * @param poolProcessing
     * @param procExecutorSrv
     */
    protected void cleanJobProcessing(final LevelJobDto job,
            final boolean poolProcessing,
            final ExecutorService procExecutorSrv) {
<span class="fc bfc" id="L333" title="All 2 branches covered.">        if (poolProcessing) {</span>
<span class="fc" id="L334">            procExecutorSrv.shutdownNow();</span>
            try {
<span class="fc" id="L336">                procExecutorSrv.awaitTermination(properties.getTmProcStopS(),</span>
                        TimeUnit.SECONDS);
                // TODO send kill if fails
<span class="nc" id="L339">            } catch (InterruptedException e) {</span>
                // Conserves the interruption
<span class="nc" id="L341">                Thread.currentThread().interrupt();</span>
<span class="fc" id="L342">            }</span>
        }
<span class="fc" id="L344">        this.eraseDirectory(job);</span>
<span class="fc" id="L345">    }</span>
    
    private void eraseDirectory(final LevelJobDto job) {
<span class="fc bfc" id="L348" title="All 2 branches covered.">        if (devProperties.getStepsActivation().get(&quot;erasing&quot;)) {</span>
            try {
<span class="fc" id="L350">                LOGGER.info(&quot;{} Erasing local working directory&quot;,</span>
<span class="fc" id="L351">                        getPrefixMonitorLog(MonitorLogUtils.LOG_ERASE, job));</span>
<span class="fc" id="L352">                Path p = Paths.get(job.getWorkDirectory());</span>
<span class="fc" id="L353">                Files.walk(p, FileVisitOption.FOLLOW_LINKS)</span>
<span class="fc" id="L354">                        .sorted(Comparator.reverseOrder()).map(Path::toFile)</span>
<span class="fc" id="L355">                        .peek(System.out::println).forEach(File::delete);</span>
<span class="nc" id="L356">            } catch (IOException e) {</span>
<span class="nc" id="L357">                LOGGER.error(</span>
                        &quot;{} [code {}] Failed to erase local working directory&quot;,
<span class="nc" id="L359">                        getPrefixMonitorLog(MonitorLogUtils.LOG_ERASE, job),</span>
<span class="nc" id="L360">                        ErrorCode.INTERNAL_ERROR.getCode());</span>
<span class="nc" id="L361">                this.appStatus.setError(&quot;PROCESSING&quot;);</span>
<span class="pc" id="L362">            }</span>
        } else {
<span class="fc" id="L364">            LOGGER.info(&quot;{} Erasing local working directory bypassed&quot;,</span>
<span class="fc" id="L365">                    getPrefixMonitorLog(MonitorLogUtils.LOG_ERASE, job));</span>
        }
<span class="fc" id="L367">    }</span>

    /**
     * Ack job processing and stop app if needed
     * @param dto
     * @param ackOk
     * @param errorMessage
     */
    protected void ackProcessing(final GenericMessageDto&lt;LevelJobDto&gt; dto,
            final boolean ackOk, final String errorMessage) {
<span class="fc" id="L377">        boolean stopping = appStatus.getStatus().isStopping();</span>

        // Ack
<span class="fc bfc" id="L380" title="All 2 branches covered.">        if (ackOk) {</span>
<span class="fc" id="L381">            ackPositively(stopping, dto);</span>
        } else {
<span class="fc" id="L383">            ackNegatively(stopping, dto, errorMessage);</span>
        }

        // Check status
<span class="fc" id="L387">        LOGGER.info(&quot;{} Checking status consumer&quot;,</span>
<span class="fc" id="L388">                getPrefixMonitorLog(MonitorLogUtils.LOG_STATUS, dto.getBody()));</span>
<span class="pc bpc" id="L389" title="1 of 2 branches missed.">        if (appStatus.getStatus().isStopping()) {</span>
            // TODO send stop to the MQI
            try {
<span class="nc" id="L392">                mqiStatusService.stop();</span>
<span class="nc" id="L393">            } catch (AbstractCodedException ace) {</span>
<span class="nc" id="L394">                LOGGER.error(&quot;{} {} Checking status consumer&quot;,</span>
<span class="nc" id="L395">                        getPrefixMonitorLog(MonitorLogUtils.LOG_STATUS,</span>
<span class="nc" id="L396">                                dto.getBody()),</span>
<span class="nc" id="L397">                        ace.getLogMessage());</span>
<span class="nc" id="L398">            }</span>
<span class="nc" id="L399">            System.exit(0);</span>
<span class="pc bpc" id="L400" title="1 of 2 branches missed.">        } else if (appStatus.getStatus().isFatalError()) {</span>
<span class="nc" id="L401">            System.exit(-1);</span>
        } else {
<span class="fc" id="L403">            appStatus.setWaiting();</span>
        }
<span class="fc" id="L405">    }</span>

    /**
     * @param dto
     * @param errorMessage
     */
    protected void ackNegatively(final boolean stop,
            final GenericMessageDto&lt;LevelJobDto&gt; dto,
            final String errorMessage) {
<span class="fc" id="L414">        LOGGER.info(&quot;{} Acknowledging negatively&quot;,</span>
<span class="fc" id="L415">                getPrefixMonitorLog(MonitorLogUtils.LOG_ACK, dto.getBody()));</span>
<span class="fc" id="L416">        LOGGER.error(errorMessage);</span>
        try {
<span class="fc" id="L418">            mqiService.ack(new AckMessageDto(dto.getIdentifier(), Ack.ERROR,</span>
                    errorMessage, stop));
<span class="fc" id="L420">        } catch (AbstractCodedException ace) {</span>
<span class="fc" id="L421">            LOGGER.error(&quot;{} [step 5] {} [code {}] {}&quot;,</span>
<span class="fc" id="L422">                    getPrefixMonitorLog(MonitorLogUtils.LOG_DFT, dto.getBody()),</span>
<span class="fc" id="L423">                    getPrefixMonitorLog(MonitorLogUtils.LOG_ERROR,</span>
<span class="fc" id="L424">                            dto.getBody()),</span>
<span class="fc" id="L425">                    ace.getCode().getCode(), ace.getLogMessage());</span>
<span class="fc" id="L426">        }</span>
<span class="fc" id="L427">        appStatus.setError(&quot;PROCESSING&quot;);</span>
<span class="fc" id="L428">    }</span>

    protected void ackPositively(final boolean stop,
            final GenericMessageDto&lt;LevelJobDto&gt; dto) {
<span class="fc" id="L432">        LOGGER.info(&quot;{} Acknowledging positively&quot;,</span>
<span class="fc" id="L433">                getPrefixMonitorLog(MonitorLogUtils.LOG_ACK, dto.getBody()));</span>
        try {
<span class="fc" id="L435">            mqiService.ack(</span>
<span class="fc" id="L436">                    new AckMessageDto(dto.getIdentifier(), Ack.OK, null, stop));</span>
<span class="fc" id="L437">        } catch (AbstractCodedException ace) {</span>
<span class="fc" id="L438">            LOGGER.error(&quot;{} [step 5] {} [code {}] {}&quot;,</span>
<span class="fc" id="L439">                    getPrefixMonitorLog(MonitorLogUtils.LOG_DFT, dto.getBody()),</span>
<span class="fc" id="L440">                    getPrefixMonitorLog(MonitorLogUtils.LOG_ERROR,</span>
<span class="fc" id="L441">                            dto.getBody()),</span>
<span class="fc" id="L442">                    ace.getCode().getCode(), ace.getLogMessage());</span>
<span class="fc" id="L443">            appStatus.setError(&quot;PROCESSING&quot;);</span>
<span class="fc" id="L444">        }</span>
<span class="fc" id="L445">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>